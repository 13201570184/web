## 2023/9/4
### p392~p426
### 浏览器现状
### PC端常见浏览器：360浏览器、谷歌浏览器、火狐浏览器、QQ浏览器、百度浏览器、搜狗浏览器、IE浏览器
### 移动端常见浏览器：UC浏览器、QQ浏览器、欧朋浏览器、百度手机浏览器、360安全浏览器、谷歌浏览器、搜狗手机浏览器、猎豹浏览器，以及其他杂牌浏览器。
### 国内的UC和QQ，百度等手机浏览器都是根据Webkit修改过来的内核，国内尚无自主研发的内核，就像国内的手机操作系统都是基于Android修改开发的一样。
### 总结：兼容移动端主流浏览器，处理Webkit内核浏览器即可。
### 视口
### 视口(viewport)就是浏览器显示页面内容的屏幕区域。视口可以分为布局视口、视觉视口和理想视口
### 布局视口 layout viewport
### 一般移动设备的浏览器都默认设置了一个布局视口，用于解决早期大的PC端页面在手机上显示的问题
### IOS,Android基本都将这个视口分辨率设置为980px，所以PC上的网页大多都能在手机上呈现，只不过元素看上去很小，一般默认可以通过手动缩放网页。
### 视觉视口 visual viewport
### 字面意思，它是用户正在看到的网站的区域。注意：是网站的区域
### 我们可以通过缩放去操作视觉视口，但不会影响布局视口，布局视口仍保持原来的宽度
### 理想视口 ideal viewport
### 为了使网站在移动端有最理想的浏览和阅读宽度而设定
### 理想视口，对设备来讲，是最理想的视口尺寸
### 需要手动添加meta视口标签通知浏览器操作
### meta视口标签的主要目的：布局视口的宽度应该与理想视口的宽度一致，简单理解就是设备有多宽，我们布局的视口就多宽
### 总结
### 视口就是浏览器显示页面内容的屏幕区域
### 视口分为布局视口、视觉视口和理想视口
### 我们移动端布局想要的是理想视口就是手机屏幕有多宽，我们的布局视口就有多宽
### 想要理想视口，我们需要给我们的移动端页面添加meta视口标签
### meta视口标签
### \<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
|属性|解释说明|
|:-|:-|
|width|宽度设置的是viewport宽度，可以设置device-width特殊值|
|initial-scale|初始缩放比，大于0的数字|
|maximum-scale|最大缩放比，大于0的数字|
|minimum-scale|最小缩放比，大于0的数字|
|user-scalable|用户是否可以缩放，yes或no(1或0)|
### 标准的viewport设置
### 视口宽度和设备保持一致
### 视口的默认缩放比例1.0
### 不允许用户自行缩放
### 最大允许的缩放比例1.0
### 最小允许的缩放比例1.0
### 二倍图
### 物理像素&物理像素比
### 像素像素点指的是屏幕显示的最小颗粒，是物理真实存在的。这是厂商在出厂时就设置好了，比如苹果6\7\8是750*1334
### 我们开发时候的1px不是一定等于1个物理像素的
### PC端页面，1个px等于1个物理像素的，但是移动端就不尽相同
### 一个px的能显示的物理像素点的个数，称为物理像素比或屏幕像素比
### PC端和早期的手机屏幕/普通手机屏幕：1CSS像素 = 1物理像素的
### Retina(视网膜屏幕)是一种显示技术，可以将把更多的物理像素点压缩至一块屏幕里，从而达到更高的分辨率，并提高屏幕显示的细腻程度
### 多倍图
### 对于一张50px*50px的图片，在手机Retina屏中打开，按照刚才的物理像素比会放大倍数，这样会造成图片模糊
### 在标准的viewport设置中，使用倍图来提高图片质量，解决在高清设备中的模糊问题
### 通常使用二倍图，因为iphone6\7\8的影响，但是现在还存在3倍图4倍图的情况，这个看实际开发公司需求
### 背景图片，注意缩放问题
### 背景缩放 background-size 
### background-size属性规定背景图像的尺寸
### 语法： background-size:背景图片宽度 背景图片高度；
### 单位： 长度/百分比/cover/contain;
### cover把背景图像扩展至足够大，以使背景图像完全覆盖背景区域
### cOntain把背景图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域
### 移动端主流方案
### 1.单独制作移动端页面(主流)
### 2.响应式页面兼容移动端(其次)
### 单独移动端页面(主流)
### 通常情况下，网址域名前面加m(mobile)可以打开移动端。通过判断设备，如果是移动设备打开，则跳到移动端页面
### 响应式兼容PC移动端
### 三星电子官网:www.samsung.com/cn/,通过判断屏幕宽度来改变样式，以适应不同终端
### 缺点:制作麻烦，需要花很大精力去调兼容性问题
### 移动端技术解决方案
### 移动端浏览器
### 移动端浏览器基本以webkit内核为主，因此我们就考虑webkit兼容性问题
### 我们可以放心使用H5标签和CSS3样式
### 同时我们浏览器的私有前缀我们只需要考虑添加webkit即可
### CSS初始化normalize.css
### 移动端CSS初始化推荐使用normalize.css/
### CSS3盒子模型box-sizing
### 传统模式宽度计算：盒子的宽度=CSS中设置的width+border+padding
### CSS3盒子模型： 盒子的宽度=CSS中设置的宽度width里面包含了border和padding也就是说，我们的CSS3中的盒子模型，padding和border不会撑大盒子了
### 语法  CSS3盒子模型：box-sizing:border-box;
###       传统盒子模型：box-sizing:content-box;
### 特殊样式
### 语法  CSS3盒子模型： box-sizing:border-box;
### -webkit-box-sizing:border-box;
### 点击高亮我们需要清除 设置为transparent 完成透明
### -webkit-tap-highlight-color: transparent;
### 在移动端浏览器默认的外观在ios上加上这个属性才能给按钮和输入框自定义样式
### -webkit-appearance: none;
### 禁止长按页面时的弹出菜单
### img,a{-webkit-touch-callout: none;}
### 移动端技术选型
### 移动端布局和以前我们学习的PC端有所区别：
### 1.单独制作移动端页面(主流)
### 流式布局(百分比布局)
### flex弹性布局(强烈推荐)
### less+rem+媒体查询布局
### 混合布局
### 2.响应式页面兼容移动端(其次)
### 媒体查询
### bootstrap
### 流式布局(百分比布局)
### 流式布局，就是百分比布局，也称非固定像素布局
### 通过了盒子的宽度设置成百分比来根据屏幕的宽度来进行伸缩，不受固定像素的限制，内容向两侧填充
### 流式布局方式是移动web开发使用的比较常见的布局方式
### max-width 最大宽度 (max-height 最大高度)
### min-width 最小宽度 (min-height 最小高度)
### 二倍精灵图做法
### 在firework里面把精灵图等比例缩放为原来的一半
### 之后根据大小测量坐标
### 注意代码里面background-size也要写：精灵图原来宽度的一半
### flex布局体验
### 传统布局与flex布局
### 传统布局：1.兼容性好  2.布局繁琐  3.局限性，不能在移动端很好的布局
### flex弹性布局：1.操作方便，布局极为简单，移动端应用很广泛  2.PC端浏览器支持情况较差  3.IE11或更低版本，不支持或仅部分支持
### 建议：1.如果是PC端页面布局，我们还是传统布局  2.如果是移动端或者不考虑兼容性问题的PC端页面布局，我们还是首页flex弹性布局
### 布局原理
### flex是flexible Box的缩写，意为"弹性布局"，用来为盒状模型提供最大的灵活性，任何一个容器都可以指定为flex布局
### 当我们为父盒子设为flex布局以后，子元素的float、clear和vertical-align属性将失效
### 伸缩布局=弹性布局=伸缩盒布局=弹性盒布局=flex布局
### 采用Flex布局的元素，称为Flex容器(flex container),简称“容器”。它的所有子元素自动成为容器成员，称为Flex项目(flex item),简称“项目”
### 总结flex布局原理：就是通过给父盒子添加flex属性，来控制子盒子的位置和排列方式
### flex布局父项常见属性
### 以下由6个属性是对父元素设置的
### flex-direction：设置主轴的方向
### justify-content：设置主轴上的子元素排列方式
### flex-wrap：设置子元素是否换行
### align-content：设置侧轴上的子元素的排列方式(多行)
### align-items：设置侧轴上的子元素排列方式(单行)
### flex-flow：复合属性，相当于同时设置了flex-direction和flex-wrap
### 1. flex-direction设置主轴的方向(重点)
### 主轴与侧轴
### 在flex布局中，是分为主轴和侧轴两个方向，同样的叫法有：行和列、x轴和y轴
### 默认主轴方向就是x轴方向，水平向右
### 默认侧轴方向就是y轴方向，垂直向下
### 属性值
### flex-direction属性决定主轴的方向(即项目的排列方向)
### 注意：主轴和侧轴是会变化的，就看flex-direction设置谁为主轴，剩下的就是侧轴。而我们的子元素是跟着主轴来排列的
|属性值|说明|
|:-|:-|
|row|默认值从左到右|
|row-reverse|从右到左|
|column|从上到下|
|column-reverse|从下到上|
### 2.justify-content设置主轴上的子元素排列方式(重点)
### justify-content 属性定义了项目在主轴上的对齐方式(注意：使用这个属性之前一定要确定好主轴是哪个)
|属性值|说明|
|:-|:-|
|flex-start|默认值从头部开始 如果主轴是x轴，则从左到右|
|flex-end|从尾部开始排列|
|center|在主轴居中对齐(如果主轴是x轴则 水平居中)|
|space-around|平分剩余空间|
|space-between|先两边贴边 再平分剩余空间(重要)|
### 3. flex-wrap 设置子元素是否换行(重点)
### 默认情况下，项目都排在一条线(又称“轴线”)上。flex-wrap属性定义，flex布局中默认是不换行的
|属性值|说明|
|:-|:-|
|nowrap|默认值，不换行|
|wrap|换行|
### 4. align-items 设置侧轴上的子元素排列方式(单行) (重点)
### 该属性是控制子项在侧轴(默认是y轴)上的排列方式 在子项为单项的时候使用
|属性值|说明|
|:-|:-|
|flex-start|从上到下|
|flex-end|从下到上|
|center|挤在一起居中(垂直居中)|
|stretch|拉伸(默认值)|
### 6. align-content 设置侧轴上的子元素的排列方式(多行)
### 设置子项在侧轴上的排列方式并且只能用于子项出现换行的情况(多行)，在单行下是没有效果的
|属性值|说明|
|:-|:-|
|flex-start|默认值在侧轴的头部开始排列|
|flex-end|在侧轴的尾部开始排列|
|center|在侧轴中间显示|
|space-around|子项在侧轴平分剩余空间|
|space-between|子项在侧轴先分布在两头，再平分剩余空间|
|stretch|设置子项元素高度平分父元素高度|
### align-content 和 align-items区别
### align-items 适用于单行情况下，只有上对齐、下对齐、居中和拉伸
### align-content 适用于换行(多行)情况下(单行情况下无效)，可以设置上对齐、下对齐、居中、拉伸以及平均分配剩余空间等属性值
### 总结就是单行找align-items 多行找 align-content
### flex-flow
### flex-flow属性是flex-direction和flex-wrap属性的复合属性
### flex-flow:row wrap;
### flex布局子项常见属性
### flex子项目占的份数
### align-self控制子项自己在侧轴的排列方式
### order属性定义子项的排列顺序(前后顺序)
### 1. flex属性(重点)
### flex属性定义子项目分配剩余空间，用flex来表示占多少份数
### 语法 .item{
###     flex: \<number>;
### }
#### align-self控制子项自己在侧轴上的排列方式
#### align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性
#### 默认值为auto,表示继承父元素的align-items属性，如果没有父元素，则等同于stretch
#### 语法： span:nth-child(2){
####   align-self: flex-end;
#### }
#### order属性定义项目的排列顺序
#### 数值越小，排列越靠前，默认为0
#### 注意：和z-index不一样
#### 语法： span:nth-child(3){
####   order:-1;
#### }
## 2023/9/5
### p427~p455
### 背景线性渐变 
### 语法  background: -webkit-linear-gradient(起始方向，颜色1，颜色2，…);
###       background: -webkit-linear-gradient(left, red, blue);
###       background: -webkit-linear-gradient(left top, red, blue);
### 背景渐变必须添加浏览器私有前缀
### 起始方向可以是：方位名词 或者度数，如果省略默认就是top
### 
### rem基础
### rem单位
### rem (root em)是一个相对单位，类似于em。em是父元素字体大小
### 不同的是rem的基准是相对于html元素的字体大小
### 比如，根元素(html)设置font-size=12px;非根元素设置width:2rem;则换成px表示就是24px
### 
### 媒体查询
### 媒体查询(Media Query)是CSS3新语法
### 使用@media查询，可以针对不同的媒体类型定义不同的样式
### @media可以针对不同的屏幕尺寸设置不同的样式
### 当你重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面
### 目前针对很多苹果手机、Android手机，平板等设备都用到多媒体查询
### 语法规范
### @media mediatype and|not|only (media feature) {
###   CSS-Code;
### }
### 用@media开头 注意@符号
### mediatype 媒体类型
### 关键字and not only
### media feature媒体特性 必须有小括号包含
### mediatype查询类型
### 将不同的终端设备划分成不同的类型，称为媒体类型
|值|解释说明|
|:-|:-|
|all|用于所有设备|
|print|用于打印机和打印预览|
|scree|用于电脑屏幕。平板电脑，智能手机等|
### 关键字
### 关键字将媒体类型或多个媒体特性连接到一起作为媒体查询的条件
### and：可以将多个媒体特性连接到一起，相当于"且“的意思
### not：排除某个媒体类型，相当于"非”的意思，可以省略
### only：指定某个特定的媒体类型，可以省略
### 媒体特性
### 每种媒体类型都具有各种不同的特性，根据不同媒体类型的媒体特性设置不同的展示风格。我们暂且了解三个。注意它们要加小括号包含
|值|解释说明|
|:-|:-|
|width|定义输出设备中页面可见区域的宽度|
|min-width|定义输出设备中页面最小可见区域的宽度|
|max-width|定义输出设备中页面最大可见区域的宽度|
### 例如： @media screen and (max-width: 800px) {
###   body{
###       background-color:green;
###   }
### }
### 这个代码表示意思是：在我们屏幕上 并且 最大的宽度是800像素 在像素小于等于800像素时 背景颜色为绿色 大于800像素时，背景颜色为默认白色
### 媒体查询+rem实现元素动态大小变化
### rem单位是跟着html来走的，有了rem页面元素可以设置不同大小尺寸
### 媒体查询可以根据不同设备宽度来修改样式
### 媒体查询+rem 就可以实现不同设备宽度，实现页面元素大小的动态变化
### 引入资源(理解)
### 当样式比较繁多的时候，我们可以针对不同的媒体使用不同stylesheets(样式表)
### 原理，就是直接在link中判断设备的尺寸，然后引用不同的css文件
### 语法规范
### \<link rel="stylesheet" media="mediatype and|not|only (media feature)" href="mystylesheet.css">
### 
### less基础
### 维护css的弊端
### CSS是一门非程序式语言，没有变量、函数、SCOPE（作用域）等概念
### CSS需要书写大量看似没有逻辑的代码，CSS冗余度是比较高的
### 不方便维护及扩展，不利于复用
### CSS没有很好的计算能力
### 非前端开发工程师来讲，往往会因为缺少CSS编写经验而很难写出组织良好且易于维护的CSS代码项目
### Less介绍
### Less (Leaner Style Sheets的缩写)是一门CSS扩展语言，也成为CSS预处理器
### 作为CSS的一种形式的扩展，它并没有减少CSS的功能，而是在现有的CSS语法上。为CSS加入程序式语言的特性
### 它在CSS的语法基础之上，引入了变量，Mixin(混入)，运算以及函数等功能，大大简化了CSS的编写，并且降低了CSS的维护成本，就像它的名称所说的那样，Less可以让我们用更少的代码做更多的事情
### Less中文网址：http://lesscss.cn/
### 常见的CSS预处理器:Sass、Less、Stylus
### 一句话：Less是一门CSS预处理语言，它扩展了CSS的动态特性
### Less使用
### 我们首先新建一个后缀名为less的文件，在这个less文件里面书写less语句
### Less变量
### 变量是指没有固定的值，可以改变的。因为我们CSS中的一些颜色和数值等经常使用
### 语法：  @变量名:值;
### Less编译
### 本质上，Less包含一套自定义的语法及一个解析器，用户根据这些语法定义自己的样式规则，这些规则最终会通过解析器、，编译生成对应的CSS文件
### 所以，我们需要把我们的less文件，编译成css文件，这样我们的html页面才能使用
### less嵌套
### 我们经常用到选择器的嵌套：
### #header .logo{
###   width:300px;
### }
### less嵌套写法
### header{
###   .logo{
###     width:300px;
###   }
### }
### 如果遇见（交集|伪类|伪元素选择器）
### 内层选择器的前面没有&符号，则它被解析为父选择器的后代；
### 如果有&符号，它就被解析为父元素自身或父元素的伪类
### 普通写法： 
### a:hover{
###   color:red;
### }
### less嵌套写法
### a{ 
###   &:hover{
###     color:red;
###   }
### }
### less运算
### 任何数字、颜色或者变量都可以参与运算。就是less提供了加(+)、减(-)、乘(*)、除(/)算术运算
### 注意：
### 乘号(*)和除号(/)的写法
### 运算符中间有个空格隔开1px + 5
### 对于两个不同的单位的值之间的运算，运算结果的值取第一个值的单位
### 如果两个值之间只有一个值有单位，则运算结果就取该单位
### 
### rem适配方案
### 1.让一些不能等比自适应的元素，达到当设备尺寸发生改变的时候，等比例适配当前设备
### 2.使用媒体查询根据不同设备按比例设置html的字体大小，然后页面元素使用rem做尺寸单位，当html字体大小变化元素尺寸也会发生变化，从而达到等比缩放的适配
### rem实际开发适配方案
### 1.按照设计稿与设备宽度的比例，动态计算并设置html根标签的font-size大小；(媒体查询)
### 2.CSS中，设计稿元素的宽、高、相对位置等取值，按照同等比例换算为rem为单位的值；
### rem适配方案技术使用(市场主流)
### 技术方案1： less   媒体查询   rem
### 技术方案2(推荐)：   flexible.js   rem
### 总结： 
### 1.两种方案现在都存在  
### 2.方案2更简单，现阶段大家无需了解里面的js代码
### rem实际开发适配方案1
### rem + 媒体查询 + less技术
### 设计稿常见尺寸宽度
### 一般情况下，我们以一套或两套效果图适应大部分的屏幕，放弃极端屏或对器优雅降级，牺牲一些效果现在基本以750为准
### 元素大小取值方法
### 1.最后的公式：页面元素的rem值=页面元素值(px)/(屏幕宽度/划分的份数)
### 2.屏幕宽度/划分的份数 就是html font-size 的大小
### 3.或者：页面元素的rem值= 页面元素(px)/ html font-size字体大小

### 响应式开发
### 响应式开发原理：就是使用媒体查询针对不同宽度的设备进行布局和样式的设置，从而适配不同的设备的目的
|设备划分|尺寸区间|
|:-|:-|
|超小屏幕(手机)|<768px|
|小屏设备(平板)|>=768px~<992px|
|中等屏幕(桌面显示器)|>=992px~<1200px|
|宽屏设备(大桌面显示器)|>=1200px|
### 响应器布局容器
### 响应式需要一个父级做为布局容器，来配合子级元素来实现变化效果
### 原理就是在不同屏幕下，通过媒体查询来改变这个布局容器的大小，再改变里面子元素的排列方式和大小，从而实现不同屏幕下，看到不同的页面布局和样式变化
### 平时我们的响应式尺寸划分
### 超小屏幕(手机，小于768px)：设置宽度为100%
### 小屏幕(平板，大于等于768px)：设置宽度为750px
### 中等屏幕(桌面显示器，大于等于992px)：设置宽度为970px
### 大屏幕(大桌面显示器，大于等于1200px)：设置宽度为1170px
### 
### bootstrap前端开发框架
### bootstrap简介
### bootstrap来自twitter(推特)，是目前最受欢迎的前端框架。bootstrap是基于HTML、CSS和JAVASCRIPT的，它简洁灵活，使得Web开发更加快捷
### 优点：
### 1.标准化的html+css编码规范
### 2.提供了一套简洁、直观、强悍的组件
### 3.有自己的生态圈，不断的更新迭代
### 4.让开发更简单，提高了开发的效率
### bootstrap使用
### 在现阶段我们还没有接触js相关课程，所以我们只考虑使用它的样式库
### 控制权在框架本身，使用者要按照框架所规定的某种规范进行开发
### bootstrap使用四步:1.创建文件夹结构 2.创建html骨架结构 3.引入相关样式文件 4.书写内容
### 布局容器
### bootstrap需要为页面内容和栅格系统包裹一个 .container容器， bootstrap预先定义好了这个类，叫做 .container它提供了两个作此用处的类 
### 1.container类
### 响应式布局的容器 固定宽度
### 大屏(>=1200px) 宽度定为1170px
### 中屏(>=992px) 宽度定位970px
### 小屏(>=768px) 宽度定为750px
### 超小屏(100%)
### 2.container-fluid类
### 1.流式布局容器百分百宽度
### 2.占据全部视口(viewport)的容器
### 3.适合于单独做移动端开发
### 栅格系统简介
### 栅格系统英文为"grid systems", 也有人翻译为"网格系统",它是指将页面布局划分为等宽的列，然后通过列数的定义来模拟化页面布局
### bootstrap提供了一套响应式、移动设备优先的流式栅格屏幕或者(视口)(viewport)尺寸的增加，系统会自动分为最多12列
### bootstrap里面container宽度是固定的，但是不同屏幕下，container的宽度不同，我们再把container划分成12等份
### 栅格选择器参数
### 栅格系统用于通过一系列的行(row)与列(column)的组合来创建网页布局，你的内容就可以放入这些创建好的布局中
||超小屏幕<768px|小屏设备>=768px|中等屏幕>=992px|宽屏设备>=1200px|
|:-:|:-:|:-:|:-:|:-:|
|.container最大宽度|自动(100%)|750px|970px|1170px|
|类前缀|.col-xs-|.col-sm-|.col-md-|.col-lg-|
### 行(row)必须放到container布局容器里面
### 我们实现列的平均划分 需要给列添加类前缀
### xs-extra small:超小的 ； sm-small：小； md-medium：中等的； lg-large：大；
### 列(column)大于12.多余的列(column)所在的元素将被作为一个整体另起一行排列
### 每一列默认有左右15像素的padding
### 可以同时为一列指定多个设备的类名，以便划分不同份数 例如 class="col-md-4 col-sm-6"
### 
### 列嵌套
### 栅格系统内置的栅格系统将内容再次嵌套。简单理解就是一个列内再分成若干份小列。我们可以通过添加一个新的.row元素和一系列.col-sm-* 元素到已存在的 .col-sm-* 元素内
### 我们列嵌套最好加1个行row这样可以取消父元素的padding值 而且高度自动和父级一样高
### 列偏移
### 使用.col-md-offset-* 类可以将列向右侧偏移。这些类实际是通过使用 * 选择器为当前元素增加了左侧的边距(margin)
### 列排序
### 通过使用 .col-md-push-* 和 .col-md-pull-* 类就可以很容易的改变列(column)的顺序
### 响应式工具
### 为了加快对移动设备友好的页面开发工作，利用媒体查询功能，并使用这些工具类可以方便的针对不同设备展示或隐藏页面内容
|类名|超小屏|小屏|中屏|大屏|
|:-:|:-:|:-:|:-:|:-:|
|.hidden-xs|隐藏|可见|可见|可见|
|.hidden-sm|可见|隐藏|可见|可见|
|.hidden-md|可见|可见|隐藏|可见|
|.hidden-lg|可见|可见|可见|隐藏|
### 隐藏hidden类标签可对一个内容加多个屏幕设备的隐藏内容
### 与之相反，是visible-xs visible-sm visible-md visible-lg 是显示某个页面内容(只会显示当前的屏幕设备，在别的屏幕设备下会隐藏)

vw / vh
目标：能够使用vw单位设置网页元素的尺寸
相对单位
相对视口的尺寸计算结果
vw: viewport width   1vw=1/100视口宽度
vh: viewport height  1vh=1/100视口高度

vw单位尺寸
1. 确定设计稿对应的vw尺寸 (1/100视口宽度)
步骤 查看设计稿宽度→确定参考设备宽度(视口宽度)→确定vw尺寸 (1/100视口宽度)
2. vw单位的尺寸=px单位数值 / (1/100视口宽度)

vh单位尺寸
1. 确定设计稿对应的vh尺寸 (1/100视口高度)
步骤 :查看设计稿宽度→确定参考设备高度(视口高度)→确定vh尺寸 (1/100视口高度)
2. vh单位的尺寸=px单位数值 / (1/100视口高度)
  
width:1vw; 和width:1%;区别
1. vw永远是以视口的宽度为准。在375设计稿下，1vw永远是3.75px
2. 百分比以父盒子为准。假如父盒子是200px，则1%是2px
 
vmin/vmax
vmin可以照顾手机端横屏和竖屏的显示效果
vmin和vmax是与当下屏幕的宽度和高度的最大值或最小值有关取决于哪个更大和更小