
### 编程语言
### 编程
### 编程：就是让计算机为解决某个问题而使用某种程序设计语言编写程序代码，并最终得到结果的过程
### 计算机程序：就是计算机所执行的一系列的指令集合，而程序全部都是用我们所掌握的语言来编写的，所以人们要控制计算机一定要通过计算机语言向计算机发出命令
### 注意：上面所定义的计算机指的是任何能够执行代码的设备，可能是智能手机、ATM机、黑莓PI、服务器等等
### 计算机语言
### 计算机语言指用于人与计算机之间通讯的语言，它是人与计算机之间传递信息的媒介
### 计算机语言的种类非常多，总的来说可以分成机器语言，汇编语言和高级语言三大类
### 实际上计算机最终所执行的都是机器语言，它是由"0"和"1"组成的二进制数，二进制是计算机语言的基础
### 编程语言
### 可以通过类似人类语言的"语言"来控制计算机，让计算机为我们做事情，这样的语言就叫做编程语言(Programming Language)
### 编程语言是用来控制计算机的一系列指令，它有固定的格式和词汇(不同编程语言的格式和词汇不一样)，必须遵守
### 如今通用的编程语言有两种形式：汇编语言和高级语言
### 汇编语言和机器语言实质是相同的，都是直接对硬件操作，只不过指令采用了英文缩写的标识符，容易识别和记忆
### 高级语言主要是相对于低级语言而言，它并不是特指某一种具体的语言，而是包括了很多编程语言，常用的有C语言、C++、Java、C#、Python、PHP、JavaScript、Go语言、Objective-C、Swift等
### 翻译器
### 高级语言所编制的程序不能直接被计算机识别，必须经过转换才能被执行，为此，我们需要一个翻译器
### 翻译器可以将我们所编写的源代码转换为机器语言，这也被称为二进制化。记住1和0
### 编程语言和标记语言区别
### 编程语言有很强的逻辑和行为能力。在编程语言里，你会看到很多if else、for、while等具有逻辑性和行为能力的指令，这是主动的
### 标记语言(html)不用于向计算机发出指令，常用于格式化和链接。标记语言的存在是用来被读取的，他是被动的
### 总结
### 1.计算机可以帮助人类解决某些问题
### 2.程序员利用编程语言编写发出指令4控制计算机来实现这些任务
### 3.编程语言有机器语言、汇编语言、高级语言
### 4.高级语言需要一个翻译器转换为计算机识别的机器语言
### 5.编程语言是主动的有很强的逻辑性
### 
### 计算机基础
### 计算机组成
### 计算机主要分为硬件和软件
### 硬件：输入设备(鼠标、键盘、手写板、摄像头等) 输出设备(显示器、打印机、投影仪等) CPU(负责处理数据与运算) 硬盘和内存(负责存储数据，硬盘永久存储数据，内存暂时存储数据)
### 软件：系统软件(Windows、Linus、macOS) 应用软件(浏览器、QQ、VSCode、Sublime、Word)
### 数据存储
### 1.计算机内部使用二进制0和1来表示数据
### 2.所有数据，包括文件、图片等最终都是以二进制数据(0和1)的形式存放在硬盘中的
### 3.所有程序，包括操作系统，本质都是各种数据，也以二进制数据的形式存放在硬盘中。平时我们所说的安装软件，其实就是把程序文件复制到硬盘中
### 4.硬盘、内存都是保存的二进制数据
### 数据存储单位
### bit<byte<kb<GB<TB<……
### 位(bit)：1bit可以保存一个0或者1（最小的存储单位）
### 字节（Byte）：1B=8b
### 千字节(KB):1KB=1024B
### 兆字节(MB):1MB=1024KB
### 吉字节（GB）:1GB=1024MB
### 太字节（TB）:1TB=1024GB
### ……
### 程序运行
### 1.打开某个程序时，先从硬盘中把程序的代码加载到内存中
### 2.CPU执行内存中的代码
### 注意：之所以要内存的一个重要原因，是因为cpu运行太快了，如果只从硬盘中读数据，会浪费cpu性能，所以，才使用存取速度更快的内存来保存运行时的数据(内存是电，硬盘是机械)
##
### 认识JavaScript
### JavaScript是什么
### JavaScript是世界上最流行的语言之一，是一种运行在客户端的脚本语言(Script是脚本的意思)
### 脚本语言：不需要编译，运行过程中由js解释器(js引擎)逐行来进行解释并执行
### 现在也可以基于Node.js技术进行服务器端编程
### JavaScript的作用
### 表单动态校验(密码强度检测) (JS产生最初的目的)
### 网页特效
### 服务端开发(Node.js)
### 桌面程序(Electron)
### App(Cordova)
### 控制硬件-物联网(Ruff)
### 游戏开发(cocos2d-js)
### HTML/CSS/JS的关系
### HTML/CSS标记语言--描述类语言
### HTML决定网页结构和内容(决定看到什么)，相当于人的身体
### CSS决定网页呈现给用户的模样(决定好看不好看)，相当于给人穿衣服、化妆
### JS脚本语言--编程类语言
### 实现业务逻辑和页面控制(决定功能)，相当于人的各种动作
### 浏览器执行JS简介
### 浏览器分成两部分：渲染引擎和JS引擎
### 渲染引擎：用来解析HTML和CSS，俗称内核，比如chrome浏览器的blink，老版本的webkit
### JS引擎：也称为JS解释器。用来读取网页中的JavaScript代码，对其处理后运行，比如chrome浏览器的V8
### 浏览器本身并不会执行JS代码，而是通过内置JavaScript引擎(解释器)来执行JS代码。JS引擎执行代码时逐行解释每一句源码(转换为机器语言)，然后由计算机去执行，所以JavaScript语言归为脚本语言，会逐行解释执行
###  JS的组成
###  JavaScript由  ECMAScript JavaScript语法   DOM页面文档对象模型   BOM浏览器对象模型
###  ECMAScript
### ECMAScript是由ECMA国际(原欧洲计算机制造商协会)进行标准化的一门编程语言，这种语言在万维网上应用广泛，它往往被为JavaScript或JScript,但实际上后两者是ECMAScript语言的实现和扩展
### ECMAScript:ECMAScript规定了JS的编程语法和基本核心知识，是所有浏览器厂商共同遵守的一套JS语法工业标准
### DOM——文档对象模型
### 文档对象模型(Document Object Model,简称DOM)，是W3C组织推荐的处理可扩展标记语言的标准编程接口。通过DOM提供的接口可以对页面上的各种元素进行操作(大小、位置、颜色等)
### BOM——浏览器对象模型
### BOM(Browser Object Model，简称BOM)是指浏览器对象模型，它提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。通过BOM可以操作浏览器窗口，比如弹出框、控制浏览器跳转。获取分辨率等
### JS初体验
### JS有3种书写位置，分别是行内、内嵌和外部
### 行内式JS
### 语法： \<input type="button" value="点我试试" onclick="alert('Hello World')"/>
### 可以将单行或少量JS代码写在HTML标签的事业属性中(以on开头的属性)。如:onclick
### 注意单双引号的使用：在HTML中我们推荐使用双引号，JS中我们推荐使用单引号
### 可读性差，在HTML中编写JS大量代码时，不方便阅读
### 引号易错，引号多层嵌套匹配时，非常容易弄混
### 特殊情况下使用
### 内嵌式JS
### 语法：\<script>
###           alert('Hello World~!');
###       \</script>
### 可以将多行JS代码写到\<script>标签中
### 内嵌式JS是学习时常用的方式
### 外部JS文件
### \<script src="my.js">\</script>
### 利用HTML页面代码结构化，把大段JS代码独立到HTML页面之外，既美观，也方便文件级别的复用
### 引用外部JS文件的Script标签中间不可以写代码
### 适合于JS代码量比较大的情况
##
### JavaScript 输入输出语句
### 为了方便信息的输入输出，JS中提供了一些输入输出语句，其常用的语句如下：
|方法|说明|归属|
|:-:|:-:|:-:|
|alert(msg)|浏览器弹出警示栏|浏览器|
|console.log(msg)|浏览器控制台打印输出信息|浏览器|
|prompt(info)|浏览器弹出输入框，用户可以输入|浏览器|
### 变量概述
### 什么是变量
### 白话：变量就是一个装东西的盒子
### 通俗：变量是用于存放数据的容器。我们通过变量名获取数据，甚至数据可以修改
### 变量在内存中的存储
### 本质：变量是程序在内存在申请的一块用来存放数据的空间
### 变量的使用
### 变量在使用时分为两步：1.声明变量 2.赋值
### 声明变量
### 语法： //声明变量
###         var age; //声明一个名称为age的变量
### var 是一个JS关键字，用来声明变量(variable 变量的意思)。使用该关键字声明变量后，计算机会自动为变量分配内存空间，不需要程序员管
### age 是程序员定义的变量名，我们要通过变量名来访问内存中分配的空间
### 赋值
### age = 10; //给age 这个变量赋值为10
###  = 用来把右边的值赋给左边的变量空间中 此处代表赋值的意思
### 变量值是程序员保存到变量空间里的值
### 变量的初始化
### var age  =18; //声明变量同时赋值为18
### 声明一个变量并赋值，我们称之为变量的初始化
### 变量语法扩展
### 更新变量
### 一个变量被重新赋值后，它原有的值就会被覆盖，变量值将以最后一次赋的值为准
### var age = 18;
### age = 81;  //最后的结果就是81 因为18被覆盖掉了
### 同时声明多个变量
### 同时声明多个变量时，只需要写一个var,多个变量名之间使用英文逗号隔开
### 语法： var age = 10, name = 'ts', color = red;
### 声明变量特殊情况
|情况|说明|结果|
|:-:|:-:|:-:|
|var age; console.log(age);|只声明 不赋值|undefined|
|console.log(age);|不声明 不赋值 直接使用|报错|
|age = 10; console.log(age);|不声明 只赋值|正常执行|
### 变量命名规范
### 由字母(A-Za-z)、数字(0-9)、下划线(_)、美元符号($)组成，如:usrAge,num01,_name
### 严格区分大小写。var app;和var App;是两个变量
### 不能以数字开头。18age 是错误的
### 不能是关键字、保留字。例如：var、for、while
### 变量名必须有意义。要有专业名称 age,或者拼音全称
### 遵守驼峰命名法。首字母小写，后面单词的首字母需要大写。myFirstName
##
### 数据类型简介
### 为什么需要数据类型
### 在计算机中，不同的数据所需占用的存储空间是不同的，为了便于把数据分成所需内存大小不同的数据，充分利用存储空间，于是定义了不同的数据类型
### 变量的数据类型
### 变量是用来存储值的所在处，它们有名字和数据类型。变量的数据类型决定了如何将代表这些值的位存储到计算机的内存中。JavaScript是一种弱类型或者说动态语言。这意味着不用提前声明变量的类型，在程序运行过程中，类型会被自动确定
### var age = 10;    //这是一个数字型
### var areYou = '上的';  //这是一个字符串
### 在代码运行时，变量的数据类型是由JS引擎根据 = 右边变量值的数据类型来判断的，运行完毕之后，变量就确定了数据类型
### JavaScript拥有动态类型，同时也意味着相同的变量可用作不同的类型：
### var x = 6;  //x为数字
### var x ='Bill';   //x为字符串   
### 数据类型的分类
### JS把数据类型分为两类
### 简单数据类型(Number,String,Boolean,Undefined,Null)
### 复杂数据类型(object)
##
### 简单数据类型
### 简单数据类型(基本数据类型)
### JavaScript中的简单数据类型及其说明如下：
|简单数据类型|说明|默认值|
|:-|:-|:-|
|Number|数字型，包含 整型值和浮点型值，如21、0.21|0|
|Boolean|布尔值类型，如true、false,等价于1和0|false|
|String|字符串类型，如"张三" 注意咱们js里面，字符串都带引号|""|
|Undefined|var a;声明了变量a但是没有给值，此时 a=undefined|undefined|
|Null|var a=null;声明了变量a 为空值|null|
### 数字型Number
### JavaScript数字类型既可以用来保存整数值，也可以保存小数(浮点数)
### var age = 21;   //整数
### var Age = 21.21;  //小数
### 数字型进制
### 最常见的进制有二进制、八进制、十进制、十六进制
### //1.八进制数字序列范围：0~7  八进制写法为 0加数字 0代表此时为八进制
### var num1 = 07；  //对应十进制的7
### var num2 = 017;   //对应十进制的15
### //2.十六进制数字序列范围：0~9 以及a~f (a~f表示数字为10~15)  十六进制写法为0x加序列范围 0x代表此时为十六进制
### var num =0xa;  //对应十进制的10
### 现阶段我们只需要记住，在JS中八进制前面加0，十六进制前面加0x   
### 数字型范围
### JavaScript中数值的最大和最小值
### alert(Number.MAX_VALUE);  //这个值表示为最大值，值为：1.7976931348623157e=308
### alert(Number.MIN_VALUE);  //这个值表示为最小值，值为：5e-32
### 数字型三个特殊值
### alert(Infinity);  //Infinity,代表无穷大，大于任何数值
### alert(-Infinity);  //-Infinity，代表无穷小，小于任何数值
### alert(NaN);   //NaN, Not a number,代表一个非数值
### isNaN()
### 用来判断一个变量是否为非数字的类型，返回true或者false
### isNaN(x),如果x是数字，返回false  如果x不是数字，返回true
##
### 字符串型String
### 字符串型可以是引号中的任意文本，其语法为双引号""或单引号''
### 因为HTML标签里面的属性使用的是双引号，JS这里我们更推荐使用单引号
### 字符串引号嵌套
### JS可以用单引号嵌套双引号，或者用双引号嵌套单引号(外双内单，外单内双)
### 字符串转义符
### 类似HTML里面的特殊字符，字符串中也有特殊字符，我们称之为转义符
### 转义符都是 \开头的，常用的转义符及其说明如下
|转义符|解释说明|
|:-|:-|
|\n|换行符，n是newline的意思|
|\\|斜杠\|
|\'|' 单引号|
|\"|" 双引号|
|\t|tab 缩进|
|\b|空格，b是blank的意思|
### 字符串长度
### 字符串是由若干字符组成，这些字符的数量就是字符串的长度。通过字符串的length属性可以获取整个字符串的长度
### 字符串拼接
### 多个字符串之间可以使用 + 进行拼接，其拼接方式为字符串+任何类型=拼接之后的新字符串
### 拼接前会把字符串相加的任何类型转成字符串，再拼接成一个新的字符串
### 字符串拼接加强
### 我们经常会将字符串和变量来拼接，因为变量可以很方便地修改里面的值
### 变量是不能添加引号的，因为加引号的变量会变成字符串
### 如果变量两侧都有字符串拼接，口诀"引引加加"，删掉数字，变量写加中间
##
### 布尔型Boolean
### 布尔类型有两个值：true和false，其中true表示真，而false表示假
### 布尔型和数字型相加的时候2，true的值为1，false的值为0
##
### Undefined 和 Null
### 一个声明后没有被赋值的变量会有一个默认值undefined(如果进行相连或者相加时，注意结果)
### 一个声明变量给null值，里面存的值为空(学习对象时，我们继续研究null)
### 假的数值或者字符有 0  ''  null  undefined NaN
##
### 获取检测变量的数据类型
### typeof可用来获取检测变量的数据类型
### 应用：  
### var num = 10;
### console.log(typeof num);    // number
### var str = 'peiqi' 
### console.log(tyepof str);   // string
### var flag = true;
### console.log(typeof flag);   // boolean
### var vari = undefined;
### console.log(typeof vari);   // undefined
### var timer = null;
### console.log(typeof timer);    // object
### 字面量
### 字面量是在源代码中一个固定值的表示法，通俗来说，就是字面量表示如何表达这个值
### 数字字面量：8，9，10
### 字符串字面量：'佩奇',"蔡徐坤"
### 布尔字面量：true,false
##
### 数据类型转换
### 什么是数据类型转换
### 使用表单、prompt获取过来的数据默认是字符串类型的，此时就不能直接简单的进行加法运算，而需要转换变量的数据类型。通俗来说，就是把一种数据类型的变量转换成另外一种数据类型
### 我们通常会实现3种方式的转换：
### 转换为字符串类型
### 转换为数字型
### 转换为布尔型
##
### 转换为字符串
|方式|说明|案例|
|:-|:-|:-|
|toString()|转成字符串|var num = 1;alert(num.toString());|
|String()强制转换|转成字符串|var num = 1;alert(String(num));|
|加号拼接字符串|和字符串拼接的结果都是字符串|var num = 1;alert(num+"我是字符串");|
### 注意：1.toString()和String()使用方式不一样
###       2.三种转换方式，我们更喜欢用第三种加号拼接字符串转换方式，这一种方式也称为隐式转换
### 转换为数字型(重点)
|方式|说明|案例|
|:-|:-|:-|
|parseInt(string)函数|将string类型转成整数数值型|parseInt('78')|
|parseFloat函数|将string类型转成浮点数数值型|parseFloat('78.21')|
|Number()强制转换函数|将string类型转换为数值型|Number('12')|
|js隐式转换(- * /)|利用算术运算隐式转换为数值型|'12'-0|
### 注意：1.parseInt和parseFloat单词的大小写，这2个是重点
###     2.隐式转换是我们在进行算数运算的时候，JS自动转换了数据类型
### 转换为布尔型
|方式|说明|案例|
|:-|:-|:-|
|Boolean()函数|说明类型转成布尔值|Boolean('true');|
### 注意：1.代表空、否定的值会被转换成false，如''、0、NaN、null、undefined
###      2.其余值都会被转换为true
##
### 算术运算符
### 算术运算符概述
### 概念：算术运算使用的符号，用于执行两个变量或值的算术运算
|运算符|描述|实例|
|:-|:-|:-|
|+|加|10 + 10=20|
|-|减|10 - 10=0|
|*|乘| 10 * 10=100|
|/|除|10 / 10=1|
|%|取余值(取模)|返回除法的余数9 % 2=1|
### 浮点数的精度问题
### 浮点数值的最高精度是17位小数，但在进行算术运算时其精准度远远不如整数
### 所以：不要直接判断两个浮点数是否相等！
### 表达式和返回值
### 表达式：是由数字、运算符、变量等以能求得数值的有意义排列方法所得的组合
### 简单理解：是由数字、运算符、变量等组成的式子
### 表达式最终都会有一个结果，返回给我们，我们称为返回值
## 
### 递增和递减运算符
### 递增和递减运算符概述
### 如果需要反复给数字变量添加或减去1，可以使用递增(++)和递减(--)运算符来完成
### 在JavaScript中，递增(++)和递减(--)既可以放在变量前面，也可以放在变量后面。放在变量前面时，我们可以称为前置递增(递减)运算符，放在变量后面时，我们可以称为后置(递减)运算符
### 注意：递增和递减运算符必须和变量配合使用
### 前置递增运算符
### ++num 前置递增，就是自加1，类似于 num= num + 1,但是 ++num写起来更简单
### 使用口诀：先自加，后返回值
### 后置递增运算符
### num++后置递增，就是自加1，类似于num=num + 1,但是num++写起来更简单
### 使用口诀：先返回原值，后自加

### 比较运算符
### 比较运算符概述
### 概念：比较运算符(关系运算符)是两个数据进行比较时所使用的运算符，比较运算后，会返回一个布尔值(true / false)作为比较运算的结果
|运算符名称|说明|案例|结果|
|:-|:-|:-|:-|
|<|小于号|1<2|true|
|>|大于号|1>2|false|
|>=|大于等于号|2>=2|true|
|<=|小于等于号|3<=2|false|
|==|判断号(会转型)|74==74|true|
|!=|不等号|37!=37|false|
|===  !==|全等 要求 值和 数据类型都一致|77==='77'|false|
##
### 等号的不同应用
|符号|作用|用法|
|:-|:-|:-|
|=|赋值|把右边给左边|
|==|判断|判断两边值是否相等(注意此时有隐式转换)|
|===|全等|判断两边的值和数据类型是否完全相同|
##
### 逻辑运算符
### 逻辑运算符概述
### 概念：逻辑运算符是用来进行布尔值运算的运算符，其返回值也是布尔值。后面开发中经常用于多个条件的判断
|逻辑运算符|说明|案例|
|:-|:-|:-|
|&&|"逻辑与"，简称"与" and|true && false|
|\|\||"逻辑或"，简称"或" or|true \|\| false|
|!|"逻辑非"，简称"非" not|!true|
##
### 逻辑与 &&
### 两边都是true才返回true，否则返回false
### 逻辑或 \|\|
### 两边都是false才返回false，否则都为true
### 逻辑非 ！
### 逻辑非(!)也叫作取反符，用来取一个布尔值相反的值，如true的相反值是false
##
### 短路运算(逻辑中断)
### 短路运算的原理：当有多个表达式(值)时，左边的表达式值可以确定结果时，就不再继续运算右边的表达式的值；
### 逻辑与
### 语法：表达式1 && 表达式2
### 如果第一个表达式的值为真，则返回表达式2
### 如果第一个表达式的值为假，则返回表达式1
### 逻辑或
### 语法：表达式1 || 表达式2
### 如果第一个表达式的值为真，则返回表达式1
### 如果第一个表达式的值为假，则返回表达式2
## 
### 赋值运算符
### 概念：用来把数据赋值给变量的运算符
|赋值运算符|说明|案例|
|:-|:-|:-|
|=|直接赋值|var usrName='我是值'|
|+=、-=|加、减一个数后再赋值|var age=10;age+=5; //15|
|*=、/=、%=|乘、除、取模后再赋值|var age=2;age *=5;  //10|
##
### 运算符优先级
|优先级|运算符|顺序|
|:-|:-|:-|
|1|小括号|()|
|2|一元运算符|++ -- !|
|3|算数运算符|先 * / % 后 + -|
|4|关系运算符|> >= < <=|
|5|相等运算符|== != === !==|
|6|逻辑运算符|先&& 后\|\||
|7|赋值运算符|=|
|8|逗号运算符|,|
### 一元运算符里面的逻辑非优先级很高
### 逻辑与比逻辑或优先级高
## 
### 流程控制
### 在一个程序执行的过程中，各条代码的执行顺序对程序的结果是有直接影响的，很多时候我们要通过控制代码的执行顺序来实现我们要完成的功能
### 简单理解：流程控制就是来控制我们的代码按照什么结构顺序来执行
### 流程控制主要有三种结构，分别是顺序结构、分支结构、和循环结构，这三种结构代表三种代码执行的顺序
### 顺序流程控制
### 顺序结构是程序中最简单、最基本的流程控制，它没有特定的语法结构，程序会按照代码的先后顺序，依次执行，程序中大多数的代码都是这样执行的
## 
### 分支流程控制if语句
### 分支结构
### 由上到下执行代码的过程中，根据不同的条件，执行不同的路径代码(执行代码多选一的过程)，从而得到不同的结果
### JS语言提供了两种分支结构语句
### if语句
### switch语句
## 
### if语句
### 语法结构
### //条件成立执行代码，否则什么也不做
### if(条件表达式){
###   //条件成立执行的代码语句
### }
### 语句可以理解为一个行为，循环语句和分支语句就是典型的语句。一个程序由很多个语句组成，一般情况下，会分割成一个一个的语句
### if else语句(双分支语句)
### 语法结构
### //条件成立 执行if里面代码，否则执行else里面的代码
### if(条件表达式){
###   //[如果]条件处理执行的代码
### }else{
###   //[否则]执行的代码
### }
### if else if 语句(多分支语句)
### 语法结构
### //适用于检查多重条件
### if(条件表达式1) {
###   语句1；
### } else if(条件表达式2) {
###   语句2；
### } else if(条件表达式3) {
###   语句3；
### } ……{
## 
### }else{
###   // 上述条件都不成立执行此代码
### }
### 三元表达式
### 三元表达式也能做一些简单的条件选择。由三元运算符组成的式子称为三元表达式
### 语法结构
### 条件表达式 ? 表达式1  : 表达式2;
### 执行思路
### 如果条件表达式结果 则返回表达式1 的值 如果条件表达式为假 则返回表达式2的值
## 
### 分支流程控制switch语句
### 语法结构
### switch语句也是多分支语句，它用于基于不同条件来执行不同的代码。当要针对变量设置一系列的特定值的选项时，就可以使用switch
### switch(表达式){
###   case value1:
###   // 表达式 等于 value1时要执行的代码
###   break;
###   case value2:
###   // 表达式 等于 value2时要执行的代码
###   break;
###   default:
###   // 表达式 不等于任何一个 value 时要执行的代码 
### }
##
### switch 语句和 if else if 语句的区别
### 1.一般情况下，它们两个语句可以相互替换
### 2.switch…case 语句通常处理case为比较确定值的情况，而if…else… 语句更加灵活，常用于范围判断(大于、等于某个范围)
### 3.switch 语句进行条件判断后直接执行到程序的条件语句，效率更高。而if…else语句有几种条件，就得判断多少次
### 4.当分支比较少时，if…else 语句的执行效率比switch语句高
### 5.当分支比较多时，switch 语句的执行效率比较高，而且结构更清晰
## 
### 循环
### 循环目的
### 在实际问题中，有许多具有规律性的重复操作，因此在程序中要完成这类操作就需要重复执行某些语句
### JS中的循环
### 在JS中，主要有三种类型的循环语句：
### for 循环
### while 循环
### do…while 循环
## 
### for循环
### 在程序中，一组被重复执行的语句被称之为循环体，能否继续执行，取决于循环的终止条件。由循环体及循环的终止条件组成的语句，被称为循环语句
### 语法结构
### for循环主要用于把某些代码循环若干次，通常跟计数有关系。其语法结构如下：
###   for(初始化变量；条件表达式；操作表达式){
###     //循环体
###   }
###   一行打印n个图标
###   我们采取追加字符串的方式，这样可以打印到控制台上
###   语法：
###   var num = prompt('请输入要打印的个数');
###   var str ='';
###   for(var i =1;i<=num;i++){
###     str = str + 'icon'
###   }
###   console.log(str);
## 
### 双重for循环
### 双重for循环概述
### 很多情况下，单层for循环并不能满足我们的需求，比如我们要打印一个5行5列的图形、打印一个倒直角三角形等，此时就可以通过循环嵌套来实现
### 循环嵌套是指在一个循环语句中再定义一个循环语句的语法结构，例如在for循环语句中，可以再嵌套一个for循环，这样的for循环语句我们称之为双重for循环
### for循环小结
### for循环可以重复执行某些相同代码
### for循环可以重复执行些许不同的代码，因为我们有计数器
### for循环可以重复执行某些操作，比如算术运算符加法操作
### 随着需求增加，双重for循环可以做更多、更好看的效果
### 双重for循环，外层循环一次，内层for循环全部执行
### for循环是循环条件和数字直接相关的循环
## 
### while循环
### while语句可以在条件表达式为真的前提下，循环执行指定的一段代码，直到表达式不为真时结束循环
### while语句的语法结构如下：
### while (条件表达式){
###   // 循环体代码
### }
### 执行思路：
### 1.先执行条件表达式，如果结果为true，则执行循环体代码；如果为false，则退出循环，执行后面代码
### 2.执行循环体代码
### 3.循环体代码执行完毕后，程序会继续执行条件表达式，如果条件仍为true，则会继续执行循环体，知道循环条件为false时，整个循环过程才会结束
## 
### do while循环
### do…while语句其实是while语句的一个变体。该循环会先执行一次代码块，然后对条件表达式进行判断，如果条件为真，就会重复执行循环体，否则退出循环
### do…while 语句的语法结构如下：
### do {
###   // 循环体代码 - 条件表达式为 true 时重复执行循环体代码
### } while(条件表达式);
### 执行思路：
### 1.先执行一次循环体代码
### 2.再执行条件表达式，如果结果为true，则继续执行循环体代码，如果为false，则退出循环，继续执行后面代码
### 注意：先执行循环体，再判断，我们会发现do…while循环语句至少会执行一次循环体代码
## 
### 循环小结
### JS中循环有for、while、do while
### 三个循环很多情况下都可以相互替换使用
### 如果是用来计次数，跟数字相关的，三者使用基本相同，但是我们更喜欢用for
### while和do…while可以做更复杂的判断条件，比for循环灵活一点
### while和do…while执行顺序不一样，while先判断后执行，do…while先执行一次，再判断执行
### while和do…while执行次数不一样，do…while至少会执行一次循环体，而while可能一次也不执行
## 
### continue break
### continue 关键字
### continue 关键字用于立即跳出本次循环，继续下一次循环(本次循环体中continue之后的代码就会少执行一次)
### 例如，吃5个包子，第3个有虫子，扔掉第3个，继续吃第4个第5个，其代码实现如下：
###  for(var i = 1; i <= 5; i++) {
###   if (i == 3) {
###     continue;  //此处表示 如果遇到i等于3的时候直接略过此处循环，包括console.log, 跳转到执行i等于4的时候继续循环
###   }
###   console.log('我正在吃第' + i + '个包子');
###  }
## 
### break 关键字
### break 关键字用于立即跳出整个循环(循环结束)
### 例如，吃5个包子，吃到第3个发现里面有半个虫子，其余的不吃了，其代码实现如下：
### for(var i =1;i <= 5;i++){
###   if(i == 3){
###     break;    //此处表示，当i等于3的时候，终止此循环，返回输出终止循环前的数据
###   }
###   console.log('正在吃第'+ i +'个包子');
### }
##
### 标识符命名规范
### 变量、函数的命名必须要有意义
### 变量的名称一般用名称
### 函数的名称一般用动词
##
### 数组的概念
### 问：之前学习的变量，只能存储一个值。如果我们想存储班级中所有学生的姓名，那么该如何存储呢？
### 答：可以使用数组(Array).数组可以把一组相关的数据一起存放，并提供方便的访问(获取)方式
### 问：什么是数组呢？
### 答：数组是指一组数据的集合，其中的每个数据被称作元素，在数组中可以存放任意类型的元素。数组是一种将一组数据存储在单个变量名下的优雅方式
### // 普通变量一次只能存储一个值
### var num = 10;
### // 数组一次可以存储多个值
### var arr = [1,2,3,4,5];
##
### 创建数组
### 数组的创建方式
### JS中创建数组有两种方式
### 1.利用 new 创建数组
### 2.利用数组字面量创建数组
## 
### 利用 new 创建数组
### var 数组名 = new Array();
### var arr = new Array();  //创建一个新的空数组
## 
### 利用数组字面量创建数组
### // 1.使用数组字面量方式创建空的数组
### var 数组名 = [];
### // 2.使用数组字面量方式创建带初始值的数组
### var 数组名 = ['燕双鹰','老八','卢本伟','蔡徐坤'];
### 数组元素的类型
### 数组中可以存放任意类型的数据，例如字符串，数字，布尔值等
### var arrStus = ['蔡徐坤',12,true,12.34];
### 数组的索引
### 索引(下标)：用来访问数组元素的序号(数组下标从0开始)
### 索引号是从0开始的，即第一个数组元素为0
### 数组可以通过索引来访问(获取)、设置、修改对应的数组元素，我们可以通过"数组名[索引]"的形式来获取数组中的元素
### //定义数组
### var arrStus = ['蔡徐坤',12,true,12.34];
### //获取数组中的第1个元素
### alert(arrStus[0]);
### 遍历数组
### 遍历：就是把数组中的每个元素从头到尾都访问一次
### 一般使用循环来实现
### var arr =[1,2,3,4,5];
### for(var i = 0 ; i < 5; i++){
###   console.log(arr[i]);
### }
### 数组的长度
### 使用"数组名.length"可以访问数组元素的数量(数组长度)
## 
### 数组中的新增元素
### 可以通过修改length长度以及索引号增加数组元素
### 通过修改 length 长度新增数组元素
### 1.可以通过修改 length 长度来实现数组扩容的目的
### length 属性是可读写的
### 通过修改数组索引新增数组元素
### 1.可以通过修改数组索引的方式追加数组元素
### 2.不能直接给数组名赋值，否则会覆盖掉以前的数据
### 这种方式也是我们最常用的一种方式
### 例如 var arr = ['red','green','blue','pink'];
###       arr[4] = 'hotpink';
###       arr = ['red','green','blue','pink','hotpink']
## 
### 函数的概念
### 在JS里面，可能会定义非常多的相同代码或者功能相似的代码，这些代码可能需要大量重复使用
### 虽然for循环语句也能实现一些简单的重复操作，但是比较具有局限性，此时我们就可以使用JS中的函数9
### 函数：就是封装了一段可被重复调用执行的代码块。通过此代码块可以实现大量代码的重复使用
### 例如  function getSum(num1, num2){
###   var sum = 0;
###   for(var i =num1; i<= num2;i++){
###     sum+=i;
###   }
###   console.log(sum)
### }
### getSum(1,123);
## 
### 函数的使用
### 函数在使用时分为两步：说明==声明函数和调用函数
### 声明函数
### 语法 //声明函数
### function 函数名(){
###   // 函数体代码
### }
### function是声明函数的关键字，必须小写
### 由于函数一般是为了实现某个功能才定义的，所以通常我们将函数名命名为动词，比如getSum
### 调用函数
### // 调用函数
### 函数名();  //通过调用函数名来执行函数体代码
### 调用的时候千万不要忘记添加小括号
### 口诀：函数不调用，自己不执行
### 注意：声明函数本身并不会执行代码，只有调用函数时才会执行函数体代码
### 函数的封装
### 函数的封装是把一个或者多个功能通过函数的方式封装起来，对外只提供一个简单的函数接口
### 简单理解：封装类似于将电脑配件整合组装到机箱中(类似快递打包)
## 
### 函数的参数
### 形参和实参
### 在声明函数时，可以在函数 名称后面的小括号中添加一些参数，这些参数被称为形参，而在调用该函数时，同样也需要传递相应的参数，这些参数被称为实参
|参数|说明|
|:-|:-|
|形参|形式上的参数 函数定义的时候 传递的参数 当前并不知道是说明|
|实参|实际上的参数 函数调用的时候传递的参数 实参是传递给形参的|
### 参数的作用：在函数内部某些值不能固定，我们可以通过参数在调用函数时传递不同的值进去
## 
### 函数形参和实参个数不匹配问题
|参数个数|说明|
|:-|:-|
|实参个数等于形参个数|输出正确结果|
|实参个数多于形参个数|只取到形参的个数|
|实参个数小于形参个数|多的形参定义为undefined,结果为NaN|
### 注意：在JavaScript中，形参的默认值是undefined
##
### 函数的返回值
### return 语句
###   有的时候，我们会希望函数将数值返回给调用者，此时通过使用 return语句就可以实现
### return 终止函数
###   return 语句之后的代码不被执行
### return 的返回值
###   return 只能返回一个值，如果用逗号隔开多个值，以最后一个为准
### 函数没有return 返回 undefined
###   函数都是有返回值的  
###   1.如果有return 则返回 return后面的值
###   2.如果没有return 则返回 undefined
## 
### break，continue,return 的区别
###   break：结束当前的循环体(如for、while)
###   continue：跳出本次循环，继续执行下次循环(如for、while)
###   return：不仅可以退出循环，还能够返回return 语句中的值，同时还可以结束当前的函数体内的代码
## 
### arguments的使用
### 当我们不确定有多少个参数传递的时候，可以用arguments来获取。在JavaScript中，arguments实际上它是当前函数的一个内置对象。所有函数都内置了一个arguments对象，arguments对象中存储了传递的所有实参
### arguments展示形式是一个伪数组，因此可以进行遍历。伪数组具有以下特点：
### 1.具有length属性
### 2.按索引方式储存数据
### 3.不具有数组的push,pop等方法

### 函数的二种声明方式
### 1.利用函数关键字自定义函数(命名函数)
### 2.函数表达式(匿名函数)语法：
### var 变量名 = function(){
###   条件;
### }
### 变量名()
### 注意：1.fun是变量名 不是函数名
###      2.函数表达式声明方式跟声明变量差不多，只不过变量里面存的是值 而 函数表达式里面存的是函数
###      3.函数表达式也可以进行传递参数
##
### 作用域
### 作用域概述
### 通常来说，一段程序代码中所用到的名字并不总是有效可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域。作用域的使用提高了程序逻辑的局部性，增强了程序的可靠性，减少了名字冲突
## 
### 变量的作用域
### 变量作用域的分类
### 在JavaScript中，根据作用域的不同，变量可以分为两种：
### 1.全局变量 ：在全局作用域下的变量 在全局下都可以使用   注意 ：如果在函数内部 没有声明直接赋值的变量也属于全局变量 (前面没有加var的变量)
### 2.局部变量 ：在局部作用域下的变量 即在函数内部的变量就是 局部变量  局部变量里的 var声明的变量只能在函数内部使用   注意 ：函数的形参实际上也是局部变量
### 从执行效率来看全局变量和局部变量
### 1.全局变量 只有浏览器关闭的时候才会销毁，比较占内存资源
### 2.局部变量 当我们程序执行完毕就会销毁，比较节约内存资源
## 
### 作用域链
### 只要是代码，就至少有一个作用域
### 写在函数内部的局部作用域
### 如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域
### 根据在内部函数可以访问外部函数变量的这种机制，用链式查找决定哪些数据能被内部函数访问，就称作作用域链
## 
### 预解析
### JavaScript代码是由浏览器中的JavaScript解析器来执行的。JavaScript解析器在运行JavaScript代码的时候分为两步：预解析和代码执行
### 1.预解析JS引擎会把JS里面的所有var 还有function提升到当前作用域的最前端
### 2.代码执行 按照代码书写的顺序从上往下执行
### 预解析分为变量预解析(变量提升)和 函数预解析(函数提升)
### 1.变量提升 就是把所有的变量声明提升到当前的作用域最前端 不提升赋值操作
### 2.函数提升 就是把所有的函数声明提升到当前作用域的最前端 不调用函数
### 函数表达式 调用必须写在函数表达式的下面
## 
### 对象
### 什么是对象？
### 在JavaScript中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象，例如字符串、数值、数组、函数等
### 对象是由属性和方法组成的
### 属性：事物的特性，在对象中用属性来表示(常用名词)
### 方法：事物的行为，在对象中用方法来表示(常用动词)
### 为什么需要对象
### 保存一个值时，可以使用变量，保存多个值(一组值)时，可以使用数组。如果要保存一个人的完整信息呢？
### 例如，将“蔡徐坤”的个人信息保存到数组中的方式为：
### var arr = ['蔡徐坤','女',18,156];
### JS中对象表达结构更清晰，更强大。蔡徐坤的个人信息在对象中的表达结构如下：
### 蔡徐坤.姓名 = '蔡徐坤';    →      person.name = '蔡徐坤';
### 蔡徐坤.性别 = '女';        →      person.sex = '女';
### 蔡徐坤.年龄 = 18;         →       person.age = 18;
### 蔡徐坤.身高 = 156;         →      person.height = 156;
## 
### 创建对象的三种方法
### 1.利用字面量创建对象
### 对象字面量：就是花括号{}里面包含了表达这个具体事迹(对象)的属性和方法
### {}里面采取键值对的形式表示
### 键：相当于属性名
### 值：相当于属性值，可以是任意类型的值(数字类型、字符串类型、布尔类型、函数类型等)
### 对象的调用
### 对象里面的属性调用：对象.属性名，这个小点 . 就理解为“的”
### 对象里面属性的另一种调用方式：对象['属性名'],注意方括号里面的属性必须加引号，我们后面会用
### 对象里面的方法调用：对象.方法名(),注意这个方法名字后面一定加括号
## 
### 变量、属性、函数、方法总结
### 变量：单独声明赋值，单独存在
### 属性：对象里面的变量称为属性，不需要声明，用来描述该对象的特征
### 函数：单独存在的，通过"函数名()"的方式就可以调用
### 方法：对象里面的函数称为方法，方法不需要声明，使用"对象.方法名()"的方式就可以调用，方法用来描述该对象的行为和功能
## 
### 利用构造函数创建对象
### 构造函数：是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与new运算符一起使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面
### 注意：
### 1.构造函数名字首字母要大写
### 2.我们构造函数不需要return 就可以返回结构
### 3.我们调用构造函数 必须使用 new
### 4.我们只要 new Star() 调用函数就创建一个对象 
### 5.我们的属性和方法前面必须添加 this
## 
### 构造函数和对象
### 1.构造函数，如 Stars(),抽象了对象的公共部分，封装了函数里面，它泛指某一大类 (class)}
### 2.创建对象,如new Star（s 特指某一个，通过new关键词创造对象的过程中我们也称为对象实例化
### new在执行时会做四件事情：
### 1.在内存中创建一个新的空对象
### 2.让this 指向这个新的对象
### 3.执行构造函数里面的代码，给这个新对象添加属性和方法
### 4.返回这个新对象(所以构造函数里面不需要return)
### 遍历对象属性
### for…in 语句用于数组或者对象的属性进行循环操作
### 语法：  for ( 变量 in 对象){
## 
### }
### 例如 for(var k in obj) {
###   console.log(k);           k是 变量 输出得到的是 属性名
###   console.log(obj[k]);      obj[k]  得到的是 属性值
### }
## 
### 内置对象
### JavaScript 中的对象分为3种：自定义对象、内置对象、浏览器对象
### 前面两种对象是JS基本内容，属于ECMAScript;第三个浏览器对象属于我们JS独有的，我们JS API讲解
### 内置对象就是指JS语言自带的一些对象，这些对象供开发者使用，并提供了一些常用的或是最基本而必要的功能(属性和方法)
### 内置对象最大的优点就是帮助我们快速开发
### JavaScript提供了多个内置对象：Math、Date、Array、String等
## 
### Math概述
### Math对象不是构造函数，它具有数学常数和函数的属性和方法。跟数学的运算(求绝对值，取整，最大值等)可以使用Math中的成员
### Math.PI   //圆周率
### Math.floor()   //  向下取整
### Math.ceil()    // 向上取整
### Math.round()    //  四舍五入版 就近取整  注意-3.5 结果是 -3
### math.abs()     //    绝对值
### Math.max()/Math.min     //     求最大和最小值
## 
### Date概述
### Date对象和Math对象不一样，他是一个构造函数，所以我们需要实例化后才能使用
### Date实例用来处理日期和时间
### Date()方法的使用
### 1.获取当前时间必须实例化
### var now = new Date();
### console.log(now);
### 2.Date()构造函数的参数
### 如果括号里面有时间，就返回参数里面的时间。例如日期格式字符串为'2019-3-4',可以写成new Date('2019-3-4')或者 new Date('2019/3/4/')
### 日期格式化
### 我们想要2019-8-8  8:8:8格式的日期，要怎么办？
### 需要获取日期指定的部分，所以我们要手动的得到这种格式
|方法名|说明|代码|
|:-|:-|:-|
|getFullYear()|获取当年|dObj.getFullYear()|
|getMonth()|获取当月(0~11)|dObj.getMonth()|
|getDate()|获取当天日期|dObj.getDate()|
|getDay()|获取星期几(周日0 到 周六6)|dObj.getDay()|
|getHours()|获取当前小时|dObj.getHours()|
|getMinutes()|获取当前分钟|dObj.getMinutes()|
|getSeconds()|获取当前秒钟|dObj.getSeconds()|
## 
### 获取日期的总的毫秒形式
### Date 对象是基于1970年1月1日(世界标准时间)起的毫秒数
### 方法1 通过valueOf() 或 getTime()
### var date = new Date();
### console.log(date.valueOf());  //就是 现在时间距离1970.1.1总的毫秒数
### console.log(date.getTime());
### 方法2 简单写法(最常用的写法)
### var date1 = +new Date();
### console.log(date1);
### 方法3 H5 新增的 获得总的毫秒数
### console.log(Date.now());
## 
### 数组对象
### 数组对象的创建
### 创建数组对象的两种方式
### 1. 字面量方式
### 2. new Array()
### 检测是否为数组
### 1. instanceof 运算符 它可以用来检测是否为数组
### var arr = [];
### var obj = {};
### console.log(arr instanceof Array);
### console.log(obj instanceof Array);
### 2. Array.isArray(参数);
### var arr = [];
### var obj = {};
### console.log(Array.isArray(arr));
### console.log(Array.isArray(obj));
## 
### 添加删除数组元素的方法
|方法名|说明|返回值|
|:-|:-|:-|
|push(参数1…)|末尾添加一个或多个元素，注意修改原数组|并返回新的长度|
|pop()|删除数组最后一个元素，把数组长度减1 无参数、修改原数组|返回它删除的元素的值|
|unshift(参数1…)|向数组的开头添加一个或更多元素，注意修改原数组|并返回新的长度|
|shift()|删除数组的第一个元素，数组长度减1 无参数、修改原数组|并返回第一个元素的值|
## 
### 数组排序
|方法名|说明|是否修改原数组|
|:-|:-|:-|
|reverse()|颠倒数组中的元素的顺序，无参数|该方法会改变原来的数组 返回新数组|
|sort()|对数组的元素进行排序|该方法会改变原来的数组 返回新数组|
### 数组排序(冒泡排序)
### var arr1 = [13, 4,6,75,7];
### arr1.sort(function(a,b){         //(function(a,b){return a- b 或 return a + b}) 固定语法
###   return a - b; 升序的顺序排列
###   return b - a; 降序的顺序排列
### })
## 
### 数组索引方法
|方法名|说明|返回值|
|:-|:-|:-|
|indexOf()|数组中查找给定元素的第一个(多个相同元素只返回第一个的位置)索引|如果存在则返回索引号 如果不存在，则返回-1|
|lastIndexOf|在数组中的最后一个索引|如果存在返回索引号 如果不存在，则返回-1|
## 
### 数组转换为字符串
|方法名|说明|返回值|
|:-|:-|:-|
|toString()|把数组转换成字符串，逗号分隔每一项|返回一个字符串|
|join('分隔符')|方法用于把数组中的所有元素转换为一个字符串|返回一个字符串|
## 
### 拓展
|方法名|说明|返回值|
|:-|:-|:-|
|concat()|连接两个或多个数组 不影响原数组|返回一个新数组|
|slice()|数组截取slice(begin,end)|返回被截取项目的新数组|
|splice()|数组删除splice(第几个开始，要删除个数)|返回被删除项目的新数组 注意，这个会影响原数组|
## 
### 字符串对象
### 基本包装类型
### 为了方便操作基本数据类型，JavaScript还提供了三个特殊的引用类型：String、Number和Boolean
### 基本包装类型就是把简单数据类型包装成为复杂数据类型，这样基本数据类型就有了属性和方法
### // 下面代码有什么问题？
### var str = 'andy';
### console.log(str.length);
### 按道理基本数据类型是没有属性和方法的，而对象才有属性和方法，但上面代码却可以执行，这是因为js会把基本数据类型包装为复杂数据类型，其执行过程如下：
### // 1.生成临时变量，把简单类型包装为复杂数据类型
### var temp = new String('andy');
### // 2.赋值给我们声明的字符变量
### str = temp;
### // 3.销毁临时变量
### temp = null;
### 字符串的不可变
### 指的是里面的值不可变，虽然看上去可以改变内容，但其实是地址变了，内存中新开辟了一个内存空间
### 根据字符返回位置
### 字符串所有的方法，都不会修改字符串本身(字符串是不可变的)，操作完成后会返回一个新的字符串
|方法名|说明|
|:-|:-|
|indexOf('要查找的字符',开始的位置)|返回指定内容在元字符串的位置，如果找不到就返回-1，开始的位置是index索引号|
|lastIndexOf()|从后往前找，只找第一个匹配的|
## 
### 根据位置返回字符串(重点)
|方法名|说明|使用|
|:-|:-|:-|
|charAt(index)|返回指定位置的字符(index字符串的索引号)|str.charAt(0)|
|charCodeAt(index)|获取指定位置处字符的ASCII码(index索引号)|str.charCodeAt(0)|
|str[index]|获取指定位置处字符|HTML5,IE8+支持 和charAt()等效|
## 
### 字符串操作方法(重点)
|方法名|说明|
|:-|:-|
|concat(str1,str2…)|concat()方法用于连接两个或多个字符串。拼接字符串，等效于+，+更常用|
|substr(start,length)|从start位置开始(索引号)，length取的个数 重点记住这个|
|slice(start,end)|从start位置开始，截取到end位置，end取不到|
|substring(start,end)|从start位置开始，截取到end位置，end取不到 基本和slice相同，但是不接受负值|
## 
### 替换字符 replace('被替换的字符','替换为的字符') 它只会替换第一个字符
### var str = 'abcd';
### console.log(str.replace('b','v'));    //输出为 avcd
### 字符转换为数组 split('分隔符')
### var str1 = 'red,green,blue';
### console.log(str1.split(','));
### var str2 = 'red & green & blue';
### console.log(str2.split('&'));
## 
### 简单类型和复杂类型
### 简单类型又叫做基本数据类型或者值类型，复杂类型又叫做引用类型
### 值类型：简单数据类型，在存储时变量中存储的是值本身，因此叫做值类型 string,number ,boolean ,undefined,null
### 引用类型：复杂数据类型，在存储时变量中存储的仅仅是地址(引用)，因此叫做引用数据类型 通过new 关键字创建的对象(系统对象，自定义对象)，如Object、Array、Date等
### 堆和栈
### 堆栈空间分配区别：
### 1.栈(操作系统)：由操作系统自动分配释放存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈；简单数据类型存放到栈里面
### 2.堆(操作系统)：存储复杂类型(对象)，一般由程序员分配缩放，若程序员不释放，由垃圾回收机制回收。复杂数据类型存放到堆里面
### 注意:JS中没有堆栈的概念，通过堆栈的方式，可以让大家更容易理解代码的一些执行方式，便于将来学习其他语言
### 简单类型的内存分配
### 值类型(简单数据类型)：string,number,boolean,undefined,null
### 值类型变量的数据直接存放在变量(栈空间)中
### 复杂类型的内存分配
### 引用类型(复杂数据类型)：通过new关键字创建的对象(系统对象、自定义对象)，如Object、Array、Date等
### 引用类型变量(栈空间)里存放的是地址，真正的对象实例存放在堆空间中
### 简单类型传参
### 数的形参也可以看做是一个变量，当我们把一个值类型作为参数传给函数的形参时，其实是把变量在栈空间里的值复制了一份给形参，那么在方法内部对形参做任何修改，都不会影响到外部变量
### 复杂类型传参
### 函数的形参也可以看做是一个变量，当我们把引用类型变量传给形参时，其实是把变量在栈空间里保存的堆地址复制给了形参，形参和实参其实保存的是同一个堆地址，所以操作的是同一个对象
## 
### Web APIs 和 JS基础关联性
### JS基础阶段以及Web APIs阶段
### JS基础阶段
### 我们学习的是ECMAScript 标准规定的基本语法
### 要求同学们掌握JS基础语法
### 只学习基本语法，做不了常用的网页交互效果
### 目的是为了 JS 后面的课程打基础、做铺垫
### Web APIs 阶段
### Web APIs 是W3C组织的标准
### Web APIs 我们主要学习DOM 和 BOM
### Web APIs 是我们JS 所独有的部分
### 我们主要学习页面交互功能
### 需要使用JS基础的课程内容做基础
## 
### API 和 Web API
### API
### API(Application Programming Interface,应用程序编程接口)是一些预先定义的函数，目的是提供应用程序与开发人员基于软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节
### 简单理解：API是给程序员提供的一种工具，以便能更轻松的实现想要完成的功能
## 
### Web API
### Web API 是浏览器提供的一套操作浏览器功能和页面元素的API(BOM 和 DOM)
### 现阶段我们主要针对于浏览器讲解常用的API，主要针对浏览器做交互效果
### 比如我们想要浏览器弹出一个警示框，直接使用alert('弹出')
### 因为 Web API很多，所以我们将这个阶段称为Web APIs
## 
### API 和 Web API 总结
### 1.API是为我们程序员提供的一个接口，帮助我们实现某种功能，我们会使用就可以了，不必纠结内部如何实现
### 2.Web API 主要是针对于浏览器提供的接口，主要针对于浏览器做交互效果
### 3.Web API一般都有输入和输出(函数的传参和返回值)，Web API很多都是方法(函数)
### 4.学习Web API可以结合前面学习内置对象方法的思路学习
## 
### DOM简介
### 什么是 DOM
### 文档对象模型(Document Object Model,简称DOM)，是W3C组织推荐的处理可扩展标记语言(HTML 或者XML)的标准编程接口
### W3C 已经定义了一系列的 DOM 接口，通过这些DOM 接口可以改变网页的内容、结构和样式
## 
### DOM 树
### 文档：一个网页就是一个文档，DOM中使用document表示
### 元素：页面中的所有标签都是元素，DOM中使用element表示
### 节点：网页中的所有内容都是节点(标签、属性、文本、注释等)，DOM中使用 node 表示
### 注意: DOM把以上内容都看作是对象
## 
### 获取元素
### 如何获取网页元素
### DOM在我们实际开发中主要用来操作元素
### 我们如何来获取页面中的元素呢？
### 1.根据ID获取
### 2.根据标签名获取
### 3.通过HTML5新增的方法获取
### 4.特殊元素获取
## 
### 根据ID 获取 
### 使用 getElementById()方法获取带有ID 的元素对象     var 变量名 = document.getElementById('id名');
## 
### 根据标签名获取
### 使用getElementsByTagName()方法可以返回带有指定标签名的对象的集合  var 变量名 = document.getElementsByTagName('标签名');
### 注意： 1.因为得到的是一个对象的集合，所以我们想要操作里面的元素就需要遍历
###       2.得到元素对象是动态的
### 还可以获取某个元素(父元素)内部所有指定标签名的子元素
### element.getElementsByTagName('标签名');
### 注意：父元素必须是单个对象(必须指明是哪一个元素对象)。获取的时候不包含父元素自己
### var 变量 = document.getElementsByTagName('标签名');  选取网页中有多个相同的标签名
### console.log(ol[0].getElementsByTagName('标签名'))    选取相同标签名中的第几个输出
## 
### 通过HTML5 新增的方法获取
### 1. document.getElementsByClassName('类名');  //根据类名返回元素对象集合
### 2. document.querySelector('选择器');      //根据指定选择器返回第一个元素对象
### 3. document.querySelectorAll('选择器');      //根据指定选择器返回
## 
### 获取特殊元素 (body ,html)
### 获取body元素    var 变量名  = document.body       //返回body元素对象
### 获取html元素    var 变量名  = document.documentElement      //返回html元素对象
## 
### 事件基础
### 事件概述
### JS使我们有能力创建动态页面，而事件是可以被JS侦测到的行为
### 简单理解：触发---相应机制
### 网页中的每个元素都可以产生某些可以触发JS的事件，例如，我们可以在用户点击某按钮时产生一个事件，然后去执行某些操作
## 
### 执行事件的步骤
### 1. 获取事件源
### 2. 注册事件(绑定事件)
### 3. 添加事件处理程序(采取函数赋值形式)
|鼠标事件|触发条件|
|:-|:-|
|onclick|鼠标点击左键触发|
|onmouseover|鼠标经过触发|
|onmouseout|鼠标离开触发|
|onfocus|获得鼠标焦点触发|
|onblur|失去鼠标焦点触发|
|onmousemove|鼠标移动触发|
|onmouseup|鼠标弹起触发|
|onmousedown|鼠标按下触发|
## 
### 操作元素
### JS的DOM操作可以改变网页内容、结构和样式，我们可以利用DOM操作元素来改变元素里面的内容、属性等。注意以下都是属性
### 改变元素内容
### element.innerText
### 从起始位置到终止位置的内容，但它去除html标签，同时空格和换行也会去掉
### element.innerHTML
### 起始位置到终止位置的全部内容，包括html标签，同时保留空格和换行
## 
### 表单元素的属性操作
### 利用DOM可以操作如下表单元素的属性
### type、value、checked、selected、disabled
## 
### 样式属性操作
### 我们可以通过JS修改元素的大小、颜色、位置等样式
### 1. element.style    行内样式操作
### 2. element.className     类名样式操作
### 注意 1. JS里面的样式采取驼峰命名法 比如 fontSize、backgroundColor
###      2. JS修改 style 样式操作，产生的是行内样式，css权重比较高
##
### 样式属性操作
### 我们可以通过JS修改元素的大小、颜色、位置等样式
### 1. element.style    行内样式操作
### 2. element.className    类名样式操作
### 注意：
### 1. 如果样式修改较多，可以采用操作类名方式更改元素样式
### 2. class因为是个保留字，因此使用className来操作元素类名属性
### 3. className 会直接更改元素的类名，会覆盖原先的类名
## 
### 排他思想
### 如果有同一组元素，我们想要某一个元素实现某种样式，需要用到循环的排他思想算法：
### 1. 所有元素全部清除样式 (干掉其他元素)
### 2. 给当前元素设置样式 (设置要求元素)
### 3. 注意顺序不能颠倒 
## 
### 自定义属性的操作
### 1. 获取属性值
### element.属性 获取属性值
### element.getAttribute('属性')
### 区别：
### element.属性 获取内置属性值(元素本身自带的属性)
### element.getAttribute('属性')；主要获得自定义的属性 (标准) 我们程序员自定义的属性
### 2. 设置属性值
### element.属性 = '值'  设置内置属性值
### element.setAttribute('属性'，'值')；
### 区别：
### element.属性  设置内置属性值
### element.setAttribute('属性','值');  主要设置自定义的属性 (标准)
### 3. 移除属性
### element.removeAttribute('属性');
## 
### H5自定义属性
### 自定义属性目的：是为了保存并使用数据。有些数距可以保存到页面中而不用保存到数据库中
### 自定义属性获取是通过getAttribute('属性')获取
### 但是有些自定义属性很容易引起歧义，不容易判断是元素的内置属性还是自定义属性
### H5给我们新增了自定义属性：
### 设置H5自定义属性
### H5规定自定义属性data-开头做为属性名并且赋值
### 比如  data-index = "1"
### 获取H5自定义属性
### 1. 兼容性获取 element.getAttribute('data-index');
### 2. H5新增element.dataset.index 或者 element.dataset['index']   IE11才开始支持
## 
### 节点操作
### 为什么学节点操作
### 获取元素通常使用两种方法
### 利用DOM提供的方法获取元素
### 1. document.getElementById()
### 2. document.getElementsByTagName()
### 3. document.querySelector等
### 4. 逻辑性不强、繁琐
### 利用节点层级关系获取元素
### 利用父子兄节点关系获取元素
### 逻辑性强，但是兼容性稍差
## 
### 节点概述
### 网页中的所有内容都是节点(标签、属性、文本、注释等)，在DOM中，节点使用node来表示
### HTML DOM树中的所有节点均可通过JS进行访问，所有HTML元素(节点)均可被修改，也可以创建或删除
### 一般地，节点至少拥有nodeType (节点类型)、nodeName (节点名称) 和 nodeValue (节点值) 这三个基本属性
### 元素节点 nodeType 为 1
### 属性节点 nodeType 为 2
### 文本节点 nodeType 为 3  (文本节点包含文字、空格、换行等)
### 
### 父级节点
### node.parentNode
### parentNode属性可返回某节点的父节点，注意是最近的一个父节点
### 如果指定的节点没有父节点则返回null
## 
### 子节点
### 1. parentNode.childNodes (标准)
### parentNode.childNodes 返回包含指定节点的子节点的集合，该集合为即时更新的集合
### 注意：返回值里面包含了所有的子节点，包括元素节点，文本节点等
### 如果只想要获得里面的元素节点，则需要专门处理。所以我们一般不提倡使用childNodes
### 用 childNodes求元素的方法为：
### var ul = document.querySelector('ul');
### for (var i = 0;i< ul.childNodes.length;i++) {
###   if (ul.childNodes[i].nodeType === 1) {
###     // ul.childNodes[i] 是元素节点
###     console.log(ul.childNodes[i]);
###   }
### }
### 2. parentNode.children (非标准)
### parentNode.children 是一个只读属性，返回所有的子元素节点。它只返回子元素节点，其余节点不返回(这个是我们重点掌握的)
### 虽然children 是一个非标准，但是得到了各个浏览器的支持，因此我们可以放心使用
### 3. parentNode.firstChild 
### firstChild返回第一个子节点，找不到则返回null.同样，也是包含所有的节点
### 4. parentNode.lastChild 
### lastChild返回最后一个子节点，找不到则返回null.同样，也是包含所有的节点
### 5. parentNode.firstElementChild
### firstElementChild 返回第一个子元素节点，找不到则返回null
### 6. parentNode.lastElementChild
### lastElementChild返回最后一个子元素节点，找不到则返回null
### 5 和 6 这两个方法有兼容性，IE9以上才支持
### 实际开发中，firstChild 和 lastChild 包含其他节点，操作不方便，而firstElementChild 和 lastElementChild 又有兼容性问题，那么我们如何获取第一个子元素节点或最后一个子元素呢？
### 解决方案：
### 取得第一个子元素节点 parentNode.children[0];  通过索引可以将元素取出
### 取得最后一个子元素节点 parentNode.children[parentNode.children.length-1]
##
### 兄弟节点
### 1. node.nextSibling
### nextSibling 返回当前元素的下一个兄弟节点，找不到则返回null.同样，也是包含所有的节点
### 2. node.previousSibling
### previousSibling 返回当前元素上一个兄弟节点，找不到则返回null。同样，也是包含所有的节点
### 3. node.nextElementSibling
### nextElementSibling返回当前元素下一个兄弟元素节点，找不到则返回null
### 4. node.previousElementSibling
### previousElementSibling返回当前元素上一个兄弟元素节点，找不到则返回null
### 3 和 4 方法有兼容性问题 ，IE9 以上才支持
### 如何解决兼容性问题？
### function getNextElementSibling(element) {
###   var el = element;
###   while (el = el.nextSibling) {
###     if(el.nodeType === 1) {
###       return el;
###     }
###   }
###   return null;
### }
##
### 创建节点
### document.createElement('tagName')
### document.createElement()方法创建由 tagName 指定的HTML元素。因为这些元素原先不存在，是根据我们的需求动态生成的，所以我们也称为动态创建元素节点
### 添加节点
### 1. node.appendChild(child)
### node.appendChild() 方法将一个节点添加到指定父节点的子节点列表末尾。类似于CSS里面的after伪元素    node代表父级元素 child代表子级元素
### 2. node.insertBefore(child,指定元素)
### node.insertBefore() 方法将一个节点添加到父节点的指定子节点前面。类似于CSS里面的before 伪元素
## 
### 删除节点
### node.removeChild(child)
### node.removeChild()方法从DOM中删除一个子节点，返回删除的节点
### 复制节点(克隆节点)
### node.cloneNode()
### node.cloneNode() 方法返回调用该方法的节点的一个副本。也称为克隆节点/拷贝节点
### 注意：
### 1. 如果括号参数为空或者为false ,则是浅拷贝，即只克隆复制节点本身(只复制标签名)，不克隆里面的子节点(不复制标签内容)
### 2. 如果括号参数为true，则是深度拷贝，会复制节点本身以及里面所有的子节点
## 
### 三种动态创建元素区别
### 1. document.write()
### 2. element.innerHTML
### 3. document.createElement()
### 区别
### 1. document.write 是直接将内容写入页面的内容流，但是文档流执行完毕，则它会导致页面全部重绘(开启新页面写入内容)
### 2. innerHTML 是将内容写入某个DOM节点，不会导致页面全部重绘
### 3. innerHTML 创建多个元素效率更高(不要拼接字符串，采取数组形式拼接)，结构稍微复杂
### 4. createElement() 创建多个元素效率稍低一点点，但是结构更清晰
### 总结：不同浏览器下，innerHTML 效率要比 createElement 高
## 
### DOM重点核心
### 文档对象模型(Document Object Model,简称DOM),是W3C组织推荐的处理可扩展标记语言(HTML或者XML)的标准编程接口
### W3C已经定义了一系列的DOM接口，通过这些DOM接口可以改变网页的内容、结构和样式
### 1. 对于JS，为了能够使JS操作HTML，JS2就有了一套自己的DOM编程接口
### 2. 对于HTML，DOM使得HTML形成一颗DOM树。包含文档、元素、节点
### 我们获取过来的DOM元素是一个对象(object)，所以称为 文档对象模型
### 关于DOM操作，我们主要针对于元素的操作。主要有创建、增、删、改、查、属性操作、事件操作
### 创建
### 1. document.write        document.write('<div>123</div>')  直接往页面后面新建一个 123的div
### 2. innerHTML            var 变量     变量.innerHTML  = '<span>天下无双</span>'   往一个变量里面添加一个span标签以及标签内容
### 3. createElement         var 变量 = document.createElement('div')    往一个变量里面添加一个标签
### 增
### 1. appendChild       var 变量     变量.appendChild(标签名) 不带引号    往变量后面添加一个标签内容
### 2. insertBefore       var 变量     变量.insertBefore(标签名,变量.children[0])    往变量里的元素中索引号为0的元素前面加一个标签
### 删
### removeChild          var 变量   变量.removeChild(变量.children[i])  通过索引号删除变量里的子元素
### 改
### 主要修改DOM的元素属性，DOM元素的内容、属性、表单的值等
### 1. 修改元素属性：src、href、title等          img.src = 'img/1.png'  可以将图片更换为 1.png 
### 2. 修改普通元素内容：innerHTML、innerText      var 变量   变量.innerHTML = 'hello,world'  innerHTML更换的是变量里面的原有属性
### 3. 修改表单元素：value、type、disabled等       value、type、disabled前面加的是符合它们的标签名  比如input.value='文本内容'  button.disabled =true / false
### 4. 修改元素样式：style、className           此类应用其标签的样式    例如  var 变量  变量.style.width = '12px'  变量.style.color = 'red'  如若引用大量的style格式的话  可以先在style 建立一个class的类名   例如 .box{w:10px h:10px}   var 变量  变量.className = 'box' 即可全部引用class里面设置的样式
### 查
### 主要获取查询DOM的元素
### 1. DOM提供的API方法：getElementById、getElementsByTagName 古老用法不太推荐    var 变量 = document.getElementById('li')  获取标签名li的元素
### 2. H5提供的新方法：querySelector、querySelectorAll 提倡     var 变量 = document.querySelector('a')  获取第一个标签a里面的内容
### 3. 利用节点操作获取元素：父(parentNode)、子(children)、兄(previousElementSibling)、弟(nextElementSibling)  兄表示同级的上一个元素 弟表示同级的下一个元素
### 属性操作
### 主要针对于自定义属性
### 1. setAttribute: 设置DOM的属性值     var 变量  变量.setAttribute('class','box')  或者 变量.setAttribute('giao',666)    
### 2. getAttribute: 得到DOM的属性值    var 变量  变量.getAttribute('value')   或者 变量.getAttribute('giao')  getAttribute可以获得自定义的属性名里的内容
### 3. removeAttribute移除属性          var 变量  变量.removeAttribute('class')  或者  变量.removeAttribute('giao')  可以移除定义的属性名及内容
### 事件操作
### 给元素注册事件，采取 事件源.事件类型 = 事件处理程序
|鼠标事件|触发条件|
|:-|:-|
|onclick|鼠标点击左键触发|
|onmouseover|鼠标经过触发|
|onmouseout|鼠标离开触发|
|onfocus|获取鼠标焦点触发|
|onblur|失去鼠标焦点触发|
|onmousemove|鼠标移动触发|
|onmouseup|鼠标弹起触发|
|onmousedown|鼠标按下触发|
##
### 注册事件(绑定事件)
### 注册事件概述
### 给元素添加事件，称为注册事件或者绑定事件
### 注册事件有两种方式：传统方式和方法监听注册方式
### 传统注册方式
### 1. 利用on 开头的事件 onclick
### 2. <button onclick = "alert('hi~')"></button>
### 3. btn.onclick = function(){}
### 4. 特点：注册事件的唯一性
### 5. 同一个元素同一个事件只能设置一个处理函数，最后注册的处理函数将会覆盖前面注册的处理函数
### 方法监听注册方式
### 1. W3C标准 推荐方式
### 2. addEventListener() 它是一个方法
### 3. IE9之前的IE不支持此方法，可使用attachEvent()代替
### 4. 特点：同一个元素同一个事件可以注册多个监听器
### 5. 按注册顺序依次执行
## 
### addEventListener 事件监听方式
### eventTarget.addEventListener(type,listener[,useCapture])       var 变量  变量.addEventListener('click',function(){alert('好好学习');})
### eventTarget.addEventListener()方法将指定的监听器注册到eventTarget(目标对象)上，当该对象触发指定的对象时，就会执行事件处理函数
### 该方法接收三个参数：
### type:事件类型字符串，比如click、mouseover,注意这里不要带on     !!!!!!!!!
### lister:事件处理函数，事件发生时，会调用该监听函数
### useCapture:可选参数，是一个布尔值，默认是false。学完DOM事件流后，我们进一步学习
## 
### attachEvent 事件监听方式
### eventTarget.attachEvent(eventNameWithOn,callback)
### eventTarget.attachEvent()方法将指定的监听器注册到eventTarget(目标对象)上，当该对象触发指定的事件时，指定的回调函数就会被执行
### 该方法接收两个参数：
### eventNameWithOn：事件类型字符串，比如onclick、onmouseover,这里要带on
### callback:事件处理函数，当目标触发事件时回调函数被调用
## 
### 注册事件兼容性解决方案
### function addEventListener(element,evenName,fn){
###   // 判断当前浏览器是否支持 addEventListener 方法
###   if(element.addEventListener){
###     element.addEventListener(eventName,fn); //第三个参数 默认是false
###   } else if (element.attachEvent) {
###     element.attachEvent('on' + eventName, fn);
###   } else{
###     // 相当于 element.onclick = fn;
###     element['on' + eventName] = fn;
###   }
### }
### 兼容性处理的原则：首先照顾大多数浏览器，再处理特殊浏览器
## 
### 删除事件(解绑事件)
### 删除事件的方式
### 传统注册方式  eventTarget.onclick = null;     var 变量  变量.onclick = function(){ }; 执行一次效果后   变量.onclick = null;
### 方法监听注册方式  
### 1. eventTarget.removeEventListener(type,listener[,useCapture]);   var 变量  function fn(){ } ; 执行一次效果后   变量.removeEventListener('click',fn);  fn不用加括号
### 2. eventTarget.detachEvent(eventNameWithOn,callback)         var 变量  变量.attachEvent('onclick',fn1);  function fn1(){ 执行一次效果后;  变量.detachEvent('onclick',fn1)}
## 
### DOM事件流
### 事件流描述的是从页面中接收事件的顺序
### 事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即DOM事件流
### DOM事件流分为3个阶段
### 1. 捕获阶段
### 2. 当前目标阶段
### 3. 冒泡阶段
### 注意：
### 1. JS代码中只能执行捕获或者冒泡其中的一个阶段
### 2. onclick 和 attachEvent 只能得到冒泡阶段
### 3. addEventListener(type,listener[,useCapture])第三个参数如果是true,表示在事件捕获阶段调用事件处理程序；如果是false(不写默认就是false),表示在事件冒泡阶段调用事件处理程序
### 4. 实际开发中我们很少使用事件捕获，我们更关注事件冒泡
### 5. 有些事件是没有冒泡的，比如 onblur、onfocus、onmouseenter、onmouseleave
### 6. 事件冒泡有时候会带来麻烦，有时候又会帮助很巧妙的做某些事，我们后面讲解
## 
### 事件对象
### 什么是事件对象
### eventTarget.onclick = function(event) {}
### eventTarget.addEventListener('click',function(event){})   //这个event 就是事件对象 我们还喜欢的写成 e 或者 evt
### 官方解释：event对象代表事件的状态，比如键盘按键的状态、鼠标的位置、鼠标按钮的状态
### 简单理解：事件发生后，跟事件相关的一系列信息数据的集合都放到这个对象里面，这个对象就是事件对象event,它有很多属性和方法
### 比如： 1. 谁绑定了这个事件  2. 鼠标触发事件的话，会得到鼠标的相关信息，如鼠标位置   3. 键盘触发事件的话，会得到键盘的相关信息，如按了哪个键
### 事件对象的使用语法
### eventTarget.onclick = function(event) {
###   //这个event 就是事件对象，我们还喜欢写成 e 或者 evt
### }
### eventTarget.addEventListener('click',function(event) {
###   //这个event 就是事件对象，我们还喜欢的写成 e 或者 evt
### })
### 这个event 是个形参，系统帮我们设定为事件对象，不需要传递实参过去
### 当我们注册事件时，event对象就会被系统自动创建，并依次传递给事件监听器(事件处理函数)
## 
### 事件对象的常见属性和方法
|事件对象属性方法|说明|
|:-|:-|
|e.target|返回触发事件的对象  标准|
|e.srcElement|返回触发事件的对象  非标准 ie6-8使用|
|e.type|返回事件的类型 比如click mouseover 不带on|
|e.cancelBubble|该属性阻止冒泡 非标准 ie6-8使用|
|e.returnValue|该属性 阻止默认事件(默认行为) 非标准 ie6-8使用 比如不让链接跳转|
|e.preventDefault()|该方法 阻止默认事件(默认行为) 标准 比如不让链接跳转|
|e.stopPropagation()|阻止冒泡 标准|
## 
### 阻止事件冒泡的两种方法
### 事件冒泡：开始时由最具体的元素接收，然后逐级向上传播到DOM最顶层节点
### 事件冒泡本身的特性，会带来的坏处，也会带来好处，需要我们灵活掌握
### 阻止事件冒泡
### 标准写法:利用事件对象里面的stopPropagation()方法
### e.stopPropagation()
### 非标准写法:IE6-8利用事件对象cancelBubble属性
### e.cancelPropagation = true;
### 阻止事件冒泡的兼容性解决方案
### if ( e && e.stopPropagation){
###   e.stopPropagation();
### } else{
###   window.event.cancelBubble = true;
### }
## 
### 事件委托 (代理、委派)
### 事件委托也称为事件代理，在JQuery里面称为事件委派
### 事件委托的原理
### 不是每个子节点单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用冒泡原理影响设置每个子节点
### 事件委托的作用
### 我们只操作了以此DOM，提高了程序的性能
## 
### 常用的鼠标事件
### 1. 禁止鼠标右键菜单
### contextmenu 主要控制应该何时显示上下文菜单，主要用于程序员取消默认的上下文菜单
### 语法: document.addEventListener('contextmenu',function(e){
###   e.preventDefault();
### })
### 2. 禁止鼠标选中(selectstart 开始选中)
### 语法： document.addEventListener('selectstart',function(e){
###   e.preventDefault();
### })
## 
### 鼠标事件对象
### event对象代表事件的状态，跟事件相关的一系列信息的集合。现阶段我们主要是用鼠标事件对象MouseEvent 和 键盘鼠标事件 KeyboardEvent
|鼠标事件对象|说明|
|:-|:-|
|e.clientX|返回鼠标相对于浏览器窗口可视区的X坐标|    var x = e.clientX
|e.clientY|返回鼠标相对于浏览器窗口可视区的Y坐标|
|e.pageX|返回鼠标相对于文档页面的X坐标 IE9+支持|
|e.pageY|返回鼠标相对于文档页面的Y坐标 IE9+支持|
|e.ScreenX|返回鼠标相对于电脑屏幕的X坐标|
|e.ScreenY|返回鼠标相对于电脑屏幕的Y坐标|
## 
### 常用键盘事件
### 事件除了使用鼠标触发，还可以使用键盘触发
|键盘事件|触发条件|
|:-|:-|
|onkeyup|某个键盘按键被松开时触发|
|onkeydown|某个键盘按键被按下时触发|
|onkeypress|某个键盘按键被按下时触发 但是它不识别功能键 比如 ctrl shift 箭头等|
### 注意：
### 1. 如果使用addEventListener 不需要加 on
### 2. onkeypress 和前面2个的区别是，它不识别功能键，比如左右箭头，shift等
### 3. 三个事件的执行顺序  keydown -- keypress -- keyup
### 注意:keydown 和 keypress 在文本框里面的特点:他们两个事件触发的时候，文字还没有落入文本框中
###      keyup事件触发的时候，文字已经落入文本框里面了
## 
### 键盘事件对象
|键盘事件对象属性|说明|
|:-|:-|
|keyCode|返回该键的ASCII值|
### 注意：onkeydown 和 onkeyup 不区分字母大小写，onkeypress区分字母大小写
### 在我们实际开发中，我们更多的使用keydown和keyup,它能识别所有键(包含功能键)
### keypress不识别功能键，但是keyCode属性能区分大小写，返回不同的ASCII值
## 
### BOM 概述
### 什么是BOM
### BOM(Browser Object Model) 即浏览器对象模型，它提供了独立于内容而与浏览器窗口进行交互的对象，其核心对象是window
### BOM由一系列相关的对象构成，并且每个对象都提供了很多方法与属性
### BOM缺乏标准，JS语法的标准化组织是ECMA，DOM的标准化组织是W3C，BOM最初是Netscape浏览器标准的一部分
### DOM
### 文档对象模型
### DOM就是把[文档] 当做一个 [对象]来看待
### DOM的顶级对象是document
### DOM主要学习的是操作页面元素
### DOM是W3C标准规范
### BOM
### 浏览器对象模型
### 把[浏览器]当做一个[对象]来看待
### BOM的顶级对象是window
### BOM学习的是浏览器窗口交互的一些对象
### BOM是浏览器厂商在各自浏览器上定义的，兼容性较差
## 
### BOM的构成
### BOM比DOM更大，它包含DOM
### window对象是浏览器的顶级对象，它具有双重角色
### 1. 它是JS访问浏览器窗口的一个接口
### 2. 它是一个全局对象。定义在全局作用域中的变量、函数都会变成window对象的属性和方法
### 3. 在调用的时候可以省略window，前面学习的对话框都属于window对象方法。如alert()、prompt()等
### 注意：window下的一个特殊属性window.name
## 
### window对象的常见事件
### 窗口加载事件
### window.onload = function(){}
### 或者
### window.addEventListener('load',function(){});
### window.onload是窗口(页面)加载事件，当文档内容完全加载完成会触发该事件(包括图像、脚本文件、CSS文件等)，就调用的处理函数
### 注意：
### 1. 有了window.onload就可以把JS代码写到页面元素的上方，因为onload是等页面内容全部加载完毕，再去执行处理函数
### 2. window.onload 传统注册事件方式只能写一次，如果有多个，会以最后一个window.onload为准
### 3. 如果使用addEventListener 则没有限制
### document.addEventListener('DOMContentLoaded',function(){})
### DOMContentLoaded事件触发时，仅当DOM加载完成，不包括样式表，图片，flash等等    ie9以上才支持
### 如果页面的图片很多的话，从用户访问到onload触发可能需要较长的时间，交互效果就不能实现，必然影响用户的体验，此时用DOMContentLoaded事件比较合适
## 
### 调整窗口大小事件
### window.onresize = function(){}
### window.addEventListener('resize',function(){});
### window.onresize 是调整窗口大小加载事件，当触发时就调用的处理函数
### 注意：
### 1. 只要窗口大小发生像素变化，就会触发这个事件
### 2. 我们经常利用这个事件完成响应式布局。window.innerWidth 当前屏幕的宽度
## 
### 定时器
### 两种定时器
### window对象给我们提供了2个非常好用的方法-定时器
### 1. setTimeout()
### 2. setInterval()
### setTimeout()定时器
### window.setTimeout(调用函数，延迟的毫秒数);
### setTimeout()方法用于设置一个定时器，该定时器在定时器到期后执行调用函数
### 注意：
### 1. window可以省略
### 2. 这个调用函数可以直接写函数，或者写函数名或者采取字符串 '函数名()'三种形式。第三种不推荐
### 3. 延迟的毫秒数省略默认是0，如果写，必须是毫秒
### 4. 因为定时器可能有很多，所以我们经常给定时器赋值一个标识符
## 
### 停止setTimeout()定时器
### window.clearTimeout(timeoutID)
### clearTimeout()方法取消了先前通过调用setTimeout()建立的定时器
### 注意：
### 1. window可以省略
### 2. 里面的参数就是定时器的标识符
## 
### setInterval()定时器
### window.setInterval(回调函数，间隔的毫秒数);
### setInterval()方法重复调用一个函数，每隔这个时间，就去调用一次回调函数
### 注意：
### 1. window可以省略
### 2. 这个调用函数可以直接写函数，或者写函数名或者采取字符串'函数名()'三种方式
### 3. 间隔的毫秒数可以省略默认是0，如果写，必须是毫秒，表示每个多少毫秒就自动调用这个函数
### 4. 因为定时器肯有很多，所以我们经常给定时器赋值一个标识符
### window.clearInterval(intervalID);
### clearInterval() 方法取消了先前通过调用 setInterval() 建立的定时器
### 注意：
### 1. window 可以省略
### 2. 里面的参数就是定时器的标识符
## 
### this
### this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，一般情况下this的最终指向的是那个调用它的对象
### 现阶段，我们先了解一下几个this指向
### 1. 全局作用域或者普通函数中this指向全局对象window(注意定时器里面的this指向window)
### 2. 方法调用中的this指向调用对象   var a = { }      在这里面的this 指向的是 a
### 3. 构造函数中的this指向函数的实例对象       unction Fun(){}  var fun = new Fun()  这里的this指向fun实例对象
## 
### JS执行机制
### JS是单线程
### JS语言的一大特点就是单线程，也就是说，同一时间只能做一件事。这是因为JS这门脚本语言诞生的使命所致——JS是为处理页面中用户的交互，以及操作DOM而诞生的。比如我们对某个DOM元素进行添加和删除操作，不能同时进行。应该先进行添加，之后再删除
### 单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。这样所导致的问题是：如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉
### 同步和异步
### 为了解决一个任务等待另一个任务太长时间，利用多核CPU的计算能力，HTML5提出Web Worker 标准，允许JS脚本创建多个线程。于是,JS中出现了同步和异步
### 同步任务
### 同步任务都在主线程上执行，形成一个执行栈
### 异步任务
### JS的异步是通过回调函数实现的
### 一般而言，异步任务有以下三种类型
### 1. 普通事件，如click、resize等
### 2. 资源加载，如load、error等
### 3. 定时器，包括setInterval、setTimeout等
### 异步任务相关回调函数添加到任务队列中(任务队列也称为消息队列)
### JS执行机制
### 1. 先执行执行栈中的同步任务
### 2. 异步任务(回调函数)放入任务队列中
### 3. 一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取任务队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行
### 由于主线程不断的重复获得任务、执行任务、再获取任务、再执行。所以这种机制被称为事件循环(event loop)
## 
### location对象
### 什么是location对象
### window对象给我们提供了一个location属性用于获取或设置窗口的URL，并且可以用于解析URL。因为这个属性返回的是一个对象，所以我们将这个属性也称为location对象
### URL
### 统一资源定位符(Uniform Resource Location,URL)是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它
## 
### URL的一般语法格式为：
### protocol://host[:port]/path/[?query]#fragment
### http://www.itcast.cn/index.html?name=andy&age=18#link
|组成|说明| 
|:-|:-| 
|protocol|通信协议 常用的http,ftp,maito等| 
|host|主机(域名) www.itheima.com| 
|port|端口号 可选，省略时使用方案的默认端口如http的默认端口为80| 
|path|路径 由零或多个'/'符号隔开的字符串，一般用来表示主机上的一个目录或文件地址| 
|query|参数 以键值对的形式，通过&符号分隔开来| 
|fragment|片段 #后面内容 常见于链接 锚点| 
## 
### location对象的属性
|location对象属性|返回值|
|:-|:-|
|location.href|获取或者设置整个URL|
|location.host|返回主机(域名) www.sp.com|
|location.port|返回端口号 如果未写 返回空字符串|
|location.pathname|返回路径|
|location.search|返回参数|
|location.hash|返回片段 #后面内容 常见于链接 锚点|
## 
### location对象的方法
|location对象方法|返回值|
|:-|:-|
|location.assign()|跟href一样，可以跳转页面(也称为重定义页面)|
|location.replace()|替换当前页面，因为不记录历史，所以不能后退页面|
|location.reload()|重新加载页面，相当于刷新按钮或者f5 如果参数为true强制刷新ctrl+f5|
## 
### navigator对象
### navigator对象包含有关浏览器的信息，它有很多属性，我们最常用的是 userAgent，该属性可以返回由客户机发送服务端的user-agent头部的值
### 下面前端代码可以判断用户那个终端打开页面，实现跳转
### if((navigator.userAgent.match(/(phone|pad|pod|iphone|ipod|ios|ipad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|SYmbian|Windows Phone)/i))){
###   window.location.href = '';  //手机
### } else{
###   window.location.href = '';  //电脑
### }
## 
### history对象
### window对象给我们提供了一个history对象，与浏览器历史记录进行交互。该对象包含用户(在浏览器窗口中)访问过的URL
|history对象方法|作用|
|:-|:-|
|back()|可以后退功能|
|forward()|前进功能|
|go(参数)|前进后退功能 参数如果是1 前进1个页面 如果是-1 后退1个页面|
## 
### 元素偏移量offset系列
### offset概述
### offset翻译过来就是偏移量，我们使用offset系列相关属性可以动态的得到该元素的位置(偏移)、大小等
### 注意：返回的数值都不带单位
### offset系列常用属性：
|offset系列属性|作用|
|:-|:-|
|element.offsetParent|返回作为该元素带有定位的父级元素 如果父级都没有定位则返回body|
|element.offsetTop|返回元素相对带有定位父级元素上方的偏移|
|element.offsetLeft|返回元素相对带有定位父级元素左边框的偏移|
|element.offsetWidth|返回自身包括padding、边框、内容区的宽度，返回数值不带单位|
|element.offsetHeight|返回自身包括padding、边框、内容区的高度，返回数值不带单位|

### offset 与 style 区别
### offset
### 1. offset可以得到任意样式表中的样式值
### 2. offset系列获得的数值是没有单位的
### 3. offsetWidth 包含padding + border + width
### 4. offsetWidth等属性是只读属性，只能获取不能赋值
### 5. 所以，我们想要获取元素大小位置，用offset更合适
### style
### 1. style只能得到行内样式表中的样式值
### 2. style.width获得的是带有单位的字符串
### 3. style.width获得不包含padding和border的值
### 4. style.width是可读写属性，可以获取也可以赋值
### 5. 所以，我们想要给元素更改值，则需要用style改变
## 
### 元素可视区client系列
### client翻译过来就是客户端，我们使用client系列的相关属性来获取元素可视区的相关信息。通过client系列的相关属性可以动态的得到该元素的边框大小、元素大小等
|client系列属性|作用|
|:-|:-|
|element.clientTop|返回元素上边框的大小|
|element.clientLeft|返回元素左边框的大小|
|element.clientWidth|返回自身包括padding、内容区的宽度，不包边框，返回数值不带单位|
|element.clientHeight|返回自身包括padding、内容区的高度，不包边框，返回数值不带单位|
## 
### 立即执行函数(function() {} ())
### 主要作用：创建一个独立的作用域
## 
### 元素滚动scroll系列
### 元素scroll系列属性
### scroll翻译过来就是滚动的，我们使用scroll系列的相关属性可以动态的得到该元素的大小、滚动距离等
|scroll系列属性|作用|
|:-|:-|
|element.scrollTop|返回被卷去的上侧距离，返回数值不带单位|
|element.scrollLeft|返回被卷去的左侧距离，返回数值不带单位|
|element.scrollWidth|返回自身实际的宽度，不含边框，返回数值不带单位|
|element.scrollHeight|返回自身实际的高度，不含边框，返回数值不带单位|
### window.pageYOffset  表示整个页面的垂直方向被滚动条卷去的距离
## 
### 注意：
### 1. offset系列经常用于获得元素位置 offsetLeft offSetTop
### 2. client经常用于获取元素大小 clientWidth clientHeight
### 3. scroll经常用于获取滚动距离 scrollTop scrollLeft
### 4. 注意页面滚动的距离通过 window.pageXOffset 获得
## 
### mouseenter 和 mouseover的区别
### 1. 当鼠标移动到元素上时就会触发mouseenter事件
### 2. 类似mouseover，它们两者之间的差别是 mouseover鼠标经过自身盒子会触发他，经过子盒子还会触发。mouseenter 只会经过自身盒子触发 之所以这样，就是因为mouseenter不会冒泡
### 3. 跟mouseenter搭配 鼠标离开 mouseleave 同样不会冒泡
## 
### 动画函数封装
### 动画实现原理
### 核心原理：通过定时器setInterval()不断移动盒子位置
### 实现步骤：
### 1. 获得盒子当前位置
### 2. 让盒子在当前位置加上1个移动距离
### 3. 利用定时器不断重复执行这个操作
### 4. 加一个结束定时器的条件
### 5. 注意此元素需要添加定位，才能使用element.style.left
## 
### 动画函数简单封装
### 注意函数需要传递2个参数，动画对象和移动到的距离
### function animate(obj,target){    //target表示目标位置
###   里面写函数执行编码
### }
### 调用函数  animate(对象,位置(数字))
## 
### 缓动效果原理
### 缓动动画就是让元素运动速度有所变化，最常见的是让速度慢慢停下来
### 思路：
### 1. 让盒子每次移动的距离慢慢减小，速度就会慢慢落下来
### 2. 核心算法:(目标值-现在的位置) / 10 作为每次移动的距离步长
### 3. 停止的条件是：让当前盒子位置等于目标位置就停止定时器
## 
### 动画函数多个目标值之间移动
### 可以让动画函数从800移动到500
### 当我们点击按钮时候，判断步长是正值还是负值
### 1. 如果是正值，则步长往大了取整 Math.ceil()
### 2. 如果是负值，则步长往小了取整 Math.floor()






